// This will convert results of MOLGEN to many .mol2 files

#include <iostream>
#include <sstream>
#include <fstream>
#include <stdio.h>
#include <iomanip>
#include <string.h>
#include <vector>
#include <map>
#include <dirent.h>
#include <time.h>
#include <sys/stat.h>
#include <matrix.h>

#include "Vector3D.h"
//#include <sysUtils.h>

typedef unsigned int uint;

const char* headerLine = "Generated by Molgen 5.0";
const char* endLine = "M  END";

const char* mol2Header1 = "@<TRIPOS>MOLECULE\n*****\n";
const char* mol2Header2 = "SMALL\nGASTEIGER\n";

const char* atomHeader = "@<TRIPOS>ATOM\n";
const char* bondHeader = "@<TRIPOS>BOND\n";

const char* goodEnd = "M  END";

const char* middlePartAtom = "   1  LIG11   ";

const std::string molecule = "mol_";
const std::string ext = ".mol2";

template <class T>
std::string to_string(T value)
{
    std::stringstream ss;
    ss << value;
    std::string str;
    ss >> str;
    return str;
}

namespace core
{
    struct time
    {
        short sec;
        short min;
        short hour;
        short day;
        short month;
        short year;

        time()  {}

        std::string timeString()
        {
            return to_string(hour) + "." +
                   to_string(min) + "." +
                   to_string(sec);
        }

        void operator++()
        {
            if (++sec > 59)
            {
                sec = 0;
                if (++min > 59)
                {
                    min = 0;
                    if (++hour > 23)
                        hour = 0;
                }

            }
        }
    };

    std::string getExt(const std::string& path)
    {
        size_t pose = path.find_last_of(".");
        if (std::string::npos == pose)
            return path;
        return std::string(path.begin() + pose + 1, path.end());
    }

    bool isFileExists(const char* path)
    {
        struct stat buffer;
        return (stat (path, &buffer) == 0); 
    }

    bool isDir(const char* path)
    {
        struct stat sb;
        return stat(path, &sb) == 0 && S_ISDIR(sb.st_mode);
    }

    bool mkDir(const char* path)
    {
        return !isDir(path) ?
            mkdir(path, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) :
            false;
    }

    bool listFiles(const std::string& path, std::vector<std::string>& files)
    {
        files.clear();
        DIR *dir;
        struct dirent *ent;
        if ((dir = opendir (path.c_str())) != NULL)
        {
            /* print all the files and directories within directory */
            while ((ent = readdir (dir)) != NULL)
            {
                if (strncmp(ent->d_name, ".", 1) == 0 ||
                    strncmp(ent->d_name, "..", 2) == 0)
                    continue;
                files.push_back(std::string(ent->d_name));
            }
            closedir (dir);
            return true;
        }
        else
        {
          /* could not open directory */
          perror ("");
          return false;
        }
    }

    std::string nameWithExt(const std::string& path)
    {
        size_t pose = path.find_last_of("\\/");
        if (std::string::npos == pose)
            return path;
        return std::string(path.begin() + pose + 1, path.end());
    }

    std::string name(const std::string& path)
    {
        size_t pose1 = path.find_last_of("\\/");
        size_t pose2 = path.find_last_of(".");
        if (std::string::npos == pose1)
            return (std::string::npos == pose2) ? path : std::string(path.begin(), path.begin() + pose2);

        return std::string(path.begin() + pose1 + 1, path.begin() + pose2);
    }
};

void getTime(core::time& t)
{
    time_t rawtime;
    struct tm  *timeinfo;

    time (&rawtime);
    timeinfo = localtime(&rawtime);

    t.sec = timeinfo->tm_sec;
    t.min = timeinfo->tm_min;
    t.hour = timeinfo->tm_hour;

    t.day = timeinfo->tm_mday;
    t.month = timeinfo->tm_mon + 1;
    t.year = 1900 + timeinfo->tm_year;
}

std::string getTime()
{
    time_t rawtime;
    struct tm  *timeinfo;
    char buffer[80];

    time (&rawtime);
    timeinfo = localtime(&rawtime);

    //strftime(buffer, 80, "%I.%M.%S", timeinfo);
    strftime(buffer, 80, "%d-%m-%Y %I:%M:%S", timeinfo);
    //std::string str = std::string(timeinfo->tm_hour) + "." + std::string(timeinfo->tm_min) + "." + std::string(timeinfo->tm_sec);
    std::string str(buffer);

    std::string newstr(str.begin() + 11, str.end());
    int pos = newstr.find_last_of(":");
    newstr[pos] = '.';
    pos = newstr.find_last_of(":");
    newstr[pos] = '.';
    //std::cout << newstr << std::endl;
    return newstr;

    //return str;
}

bool parseMolgen(const std::string& path)
{
    bool res = false;
    const int maxSymbols = 200;
    char str[maxSymbols];

    FILE* inFile = fopen(path.c_str(), "r");

    while (inFile != NULL && fgets(str, maxSymbols, inFile))
    {
        if (0 == strncmp(headerLine, str, sizeof(headerLine)))
        {
            core::time t;
            getTime(t);
            std::string timeStr = t.timeString();

            while (core::isFileExists((molecule + timeStr + ext).c_str()))
            {
                ++t;
                timeStr = t.timeString();
            }
            std::string path = molecule + timeStr + ext;

            std::ofstream ofs(path.c_str());
            ofs << mol2Header1;

            //fscanf(inFile, "%d %d", numAtom, numBond)
            fgets(str, maxSymbols, inFile);     // here we have empty line
            fgets(str, maxSymbols, inFile);

            std::istringstream iss(str);
            int numAtom = 0, numBond = 0;
            if ((iss >> numAtom >> numBond) && numAtom > 0 && numBond > 0)
            {
                ofs << " " << numAtom << " " << numBond << " 0 0 0\n";
                ofs << mol2Header2 << "\n" << atomHeader;
                for (int i = 0; i < numAtom; ++i)
                {
                    float x, y, z;
                    std::string atom;
                    fgets(str, maxSymbols, inFile);
                    std::istringstream iss1(str);
                    if ((iss1 >> x >> y >> z >> atom) && !atom.empty())
                        ofs << "\t" << i+1 << "\t" << atom << "\t" << x << "\t" << y << "\t" << z << "\t" << atom << middlePartAtom << "0\n";
                }

                ofs << bondHeader;
                for (int i = 0; i < numBond; ++i)
                {
                    int b, e, mult; // begin, end, multiplicity
                    fgets(str, maxSymbols, inFile);
                    std::istringstream iss1(str);
                    if ((iss1 >> b >> e >> mult) && b > 0 && e > 0 && mult > 0)
                        ofs << "\t" << i+1 << "\t" << b << "\t" << e << "\t" << mult << "\n";
                }
            }
            fgets(str, maxSymbols, inFile);
            res = 0 == strncmp(endLine, str, sizeof(endLine));
            ofs.close();
        }

        //printf("This line = %s", str);
    }

    return res;
}


// map: first - name, second - atom mass
std::map<std::string, int> _mendel;
// map: first - name, second - valence
std::map<std::string, int> _valences;
// map: first - bond, second - num;
std::map<std::string, int> _bonds;
// map: first - bond, second - num;
std::map<std::string, float> _radii;

const std::string resFile_HO = "resFile_HO";
const std::string resFile_HCa = "resFile_HCa";
const std::string resFile_HP = "resFile_HP";
const std::string resFile_OO = "resFile_OO";
const std::string resFile_OP = "resFile_OP";
const std::string resFile_OCa = "resFile_OCa";
const std::string resFile_PP = "resFile_PP";
const std::string resFile_PCa = "resFile_PCa";
const std::string resFile_CaCa = "resFile_CaCa";

const std::string divider = "=====";

void fillMendelAndValences()
{
    _mendel["H"] = 1;
    _mendel["O"] = 16;
    _mendel["P"] = 31;
    _mendel["Ca"] = 40;

    _valences["H"] = 1;
    _valences["O"] = 2;
    _valences["P"] = 5;
    _valences["Ca"] = 2;

    _radii["H"] = 0.31f;
    _radii["O"] = 0.66f;
    _radii["P"] = 1.07f;
    _radii["Ca"] = 1.76f;

    int i = 0;
    _bonds["HO"] = ++i;
    _bonds["HCa"] = ++i;
    _bonds["HP"] = ++i;
    _bonds["OO"] = ++i;
    _bonds["OP"] = ++i;
    _bonds["OCa"] = ++i;
    _bonds["PP"] = ++i;
    _bonds["PCa"] = ++i;
    _bonds["CaCa"] = ++i;

    std::ofstream outfile(resFile_HO.c_str());
    outfile << resFile_HO << std::endl;
    outfile.close();

    std::ofstream outfile1(resFile_HCa.c_str());
    outfile1 << resFile_HCa << std::endl;
    outfile1.close();

//    std::ofstream outfile2(resFile_HO.c_str());
//    outfile2 << resFile_HO << std::endl;
//    outfile2.close();

    std::ofstream outfile3(resFile_HP.c_str());
    outfile3 << resFile_HP << std::endl;
    outfile3.close();

    std::ofstream outfile4(resFile_OO.c_str());
    outfile4 << resFile_OO << std::endl;
    outfile4.close();

    std::ofstream  outfile5(resFile_OP.c_str());
    outfile5 << resFile_OP << std::endl;
    outfile5.close();
    
    std::ofstream outfile6(resFile_CaCa.c_str());
    outfile6 << resFile_CaCa << std::endl;
    outfile6.close();

    std::ofstream outfile7(resFile_PP.c_str());
    outfile << resFile_PP << std::endl;
    outfile.close();

    std::ofstream outfile8(resFile_PCa.c_str());
    outfile << resFile_PCa << std::endl;
    outfile.close();

    std::ofstream outfile9(resFile_CaCa.c_str());
    outfile << resFile_CaCa << std::endl;
    outfile.close();
}

struct Atom
{
    std::string mName;
    Vector3D mCoord;
    int mValence;
};

struct Molecule
{
    std::vector<Atom> mAtoms;
    std::string mName;
    std::string mPath;
    std::map<std::string, int> mBonds;
    unsigned int hash;
    float mEnergy;

    uint getHash()
    {
        hash = 0;
        if (!mBonds.empty() && !mAtoms.empty())
        {
            for (std::map<std::string, int>::iterator it = _bonds.begin();
                 it != _bonds.end(); ++it)
            {
                unsigned int bond = mBonds[it->first];
                hash += bond;
                hash *= 10;
            }
        }
        return hash;
    }

    uint mustBeBonds()
    {
        uint num = 0;
        for (int i = 0, size = mAtoms.size(); i < size; ++i)
            num += _valences[mAtoms[i].mName];
        return num / 2;
    }

    uint getBondsNum()
    {
        uint num = 0;
        if (!mBonds.empty())
        {
            for (std::map<std::string, int>::iterator it = _bonds.begin();
                 it != _bonds.end(); ++it)
                num += mBonds[it->first];
        }
        return num;
    }
};

// Fill distances files and bonds 
void fillDistancesAndBonds(const Molecule& mol, std::ofstream& ofs)
{

    std::map<std::string, int> bonds;       // num bonds in molecule
    const int size = mol.mAtoms.size();
    
    std::vector< std::vector<char> > matrixBonds;
    std::vector<char> tmp(size, 0);
    for (int i = 0; i < size; ++i)
        matrixBonds.push_back(tmp);


    std::map<std::pair<std::string,int>, int> binding;     // respond to current binding in molecule

    for (int i = 0; i < size; ++i)
    {
        Atom atom1 = mol.mAtoms[i];
        std::string s1 = atom1.mName;
        std::map<float, std::pair<std::string, int> > distances; // to another atoms
        for (int j = i + 1; j < size; ++j)
        {
            Atom atom2 = mol.mAtoms[j];
            std::string s2 = atom2.mName;
            
            float magnitude = int(1000 * Magnitude(atom1.mCoord - atom2.mCoord)) / 1000.f;
            distances[magnitude] = std::make_pair(s2, j);
            
        }
        
        int v = 0,
            valence = _valences[s1];
        for (std::map<float, std::pair<std::string, int> >::iterator it = distances.begin();
             it != distances.end() && v < valence; ++it)
        {
            std::pair<std::string, int> endAtom = it->second;
            if (!matrixBonds[i][endAtom.second] && !matrixBonds[endAtom.second][i] &&
                binding[std::make_pair(s1, i)] < _valences[s1] &&
                binding[endAtom] < _valences[endAtom.first])
            {
                ++binding[std::make_pair(s1, i)];
                ++binding[endAtom];
                std::string bond = _mendel[s1] < _mendel[endAtom.first] ? s1 + endAtom.first : endAtom.first + s1;
                ++bonds[bond];
                matrixBonds[i][endAtom.second] = matrixBonds[endAtom.second][i] = 1;
                ++v;
            }
        }
    }

    for (std::map<std::string, int>::iterator it = _bonds.begin();
         it != _bonds.end(); ++it)
        ofs << it->first << "\t";
    ofs << std::endl;

    for (std::map<std::string, int>::iterator it = _bonds.begin();
         it != _bonds.end(); ++it)
        ofs << bonds[it->first] << "\t";
    ofs << std::endl;
}

void fillDistancesAndBonds1(Molecule& mol)
{
    mol.mBonds.clear();
    const int size = mol.mAtoms.size();

    std::map<int, std::vector<std::pair<int, int> > > distances;

    uint numSemiBonds = 0;
    for (int i = 0; i < size; ++i)
    {
        Atom atom1 = mol.mAtoms[i];
        numSemiBonds += atom1.mValence;
        for (int j = i + 1; j < size; ++j)
        {
            Atom atom2 = mol.mAtoms[j];
            int magnitude = int(1000 * Magnitude(atom1.mCoord - atom2.mCoord));
            distances[magnitude].push_back(std::make_pair(i, j));
        }
    }

//    int num = 0;
//    for (std::map<int, std::vector<std::pair<int, int> > >::iterator it = distances.begin();
//         num < numSemiBonds / 2; ++it)
//    {
//        int sizeSize = it->second.size();
//        for (int i = 0; i < sizeSize; ++i)
//        {
//            std::pair<int, int> thisPair = it->second[i];
//            const std::string name1 = mol.mAtoms[thisPair.first].mName;
//            const std::string name2 = mol.mAtoms[thisPair.second].mName;
//            const std::string res = _mendel[name1] < _mendel[name2] ? name1 + name2 : name2 + name1;
//            ++mol.mBonds[res];
//            ++num;
//        }
//    }


    int num = 0;
    for (std::map<int, std::vector<std::pair<int, int> > >::iterator it = distances.begin();
         num < numSemiBonds / 2 && it != distances.end(); ++it)
    {
        std::vector<std::pair<int, int> > tmpBonds = it->second;
        const int tmpBondsSize = tmpBonds.size();
        for (int i = 0; i < tmpBondsSize && num < numSemiBonds / 2; ++i)
        {
            std::pair<int, int> bond = tmpBonds[i];
            const std::string name1 = mol.mAtoms[bond.first].mName;
            const std::string name2 = mol.mAtoms[bond.second].mName;

            const float equilibriumDist = _radii[name1] + _radii[name2];
            const float curDist = it->first / 1000.f;
            const float ratioDist = fabs(curDist - equilibriumDist) / equilibriumDist;
//            if ((name1 == "Ca" || name2 == "Ca") && ratioDist < 0.4f)
//            {
//                const std::string res = _mendel[name1] < _mendel[name2] ? name1 + name2 : name2 + name1;
//                ++mol.mBonds[res];
//                ++num;
//            } else
            if (ratioDist < 0.2f)
            {
                const std::string res = _mendel[name1] < _mendel[name2] ? name1 + name2 : name2 + name1;
                ++mol.mBonds[res];
                ++num;
            }
        }
    }
}

bool readFromFile(Molecule& mol)
{
    if (!mol.mPath.empty())
    {
        FILE* inFile = fopen(mol.mPath.c_str(), "r");
        if (inFile)
        {
            int numAtoms = 0;
            fscanf(inFile, "%d", &numAtoms);
            
            mol.mAtoms.assign(numAtoms, Atom());
            
            for (int j = 0; j < numAtoms; ++j)
            {
                Atom* atom = &(mol.mAtoms[j]);
                char name[4]; // max name of atom have 4 symbols
                fscanf(inFile, "%s", &name);
                atom->mName = std::string(name);
                fscanf(inFile, "%f %f %f", &(atom->mCoord.x), &(atom->mCoord.y), &(atom->mCoord.z));
                atom->mValence = _valences[name];
            }
            
            fclose(inFile);
            return true;
        }
    }
    
    return false;
}

void readEnergies(const std::string& energyList, std::map<float, std::string>& energies,
                  std::map<std::string, float>& invertedEnergies)
{
    energies.clear();
    invertedEnergies.clear();
    const int maxSymbols = 200;
    char str[maxSymbols];
    FILE* inFile1 = fopen(energyList.c_str(), "r");

    while(fgets(str, maxSymbols, inFile1))
    {
         std::istringstream iss(str);
         float energy = 0.f;
         float firstFreq = 0.f;
         std::string name;
         if ((iss >> name >> energy >> firstFreq) && !name.empty() && firstFreq > 0.f)
         {
             size_t pose = name.find_first_of(".");
             name = std::string::npos == pose ? name : std::string(name.begin(), name.begin() + pose);
             energies[energy] = name;
             invertedEnergies[name] = energy;
         }
    }
}

bool readSets(const std::string& path, std::vector<std::vector<std::string> >& sets)
{
    bool res = false;
    sets.clear();
    if (core::isFileExists(path.c_str()))
    {
        std::ifstream ifs(path.c_str());
        std::string name;
        std::vector<std::string> names;
        while (!ifs.eof())
        {
            ifs >> name;
            if (0 == divider.compare(name))
            {
                if (!names.empty())
                    sets.push_back(names);
                names.clear();
            }
            else
                names.push_back(std::string(name));
        }
        res = true;
    }
    return res;
}

bool writeMolMap(const int& num, std::map<uint, Molecule>& molMap, const std::string& resDir)
{
    if (!molMap.empty()) {
        int i = 0;

        std::ofstream ofsBonds((resDir + "bonds.txt").c_str(), std::ios_base::app);
        std::ofstream ofsEnergy((resDir + "energy.txt").c_str(), std::ios_base::app);

        for (std::map<uint, Molecule>::iterator itMol = molMap.begin();
             itMol != molMap.end(); ++itMol, ++i)
        {
            Molecule mol = itMol->second;
            ofsEnergy << mol.mEnergy << std::endl;

            int j = 1;
            switch (num)
            {
            case 0:
                ofsBonds << "1\t0\t0\t";
                break;
            case 1:
                ofsBonds << "0\t1\t0\t";
                break;
            case 2:
                ofsBonds << "0\t0\t1\t";
                break;
            }

            for (std::map<std::string, int>::iterator it = _bonds.begin();
                 it != _bonds.end(); ++it, ++j)
                ofsBonds << mol.mBonds[it->first] << "\t";
            ofsBonds << std::endl;
        }

        ofsBonds.close();
        ofsEnergy.close();
    }
}

// return -1 if false, and num of atom if successful
void findDoubleOBond(const Molecule& mol)
{
    assert(!mol.mAtoms.empty());

    std::ofstream ofs("resultDoubleBonds", std::ios_base::app);

    const uint size = mol.mAtoms.size();
    for (int i = 0; i < size; ++i)
    {
        const Atom* atom1 = &(mol.mAtoms[i]);
        if (0 == atom1->mName.compare("O"))
        {
            int endAtom = -1;
            uint numNeighborAtoms = 0;
            for (int j = 0; j < size; ++j)
            {
                const Atom* atom2 = &(mol.mAtoms[j]);

                const float equilibriumDist = _radii["O"] + _radii[atom2->mName];
                const float dist = (atom1->mCoord - atom2->mCoord).Magnitude();
                const float ratio = fabs(dist - equilibriumDist) / equilibriumDist;
                if (ratio < 0.2f)
                {
                    ++numNeighborAtoms;
                    endAtom = j;
                }
            }

            if (numNeighborAtoms == 1)
            {
                ofs << mol.mName << "\t" << i << "\t" << endAtom << "\t" << mol.mEnergy << std::endl;
                std::cout << mol.mName << "\t" << i << "\t" << endAtom << "\t" << mol.mEnergy << std::endl;
            }
        }
    }

    ofs.close();
}

int main(int argc, char* argv[])
{
    std::string argFile;
    if (argc > 1)
    {
        for (int i = 0; i < argc; ++i)
        {
            const char* param = argv[i];
            if (0 == strncmp(param, "-in=", 4))
                argFile = param + 4;
        }
    }

    std::string resDir = argFile + "/Results/";
    if (!core::isDir(resDir.c_str()))
        core::mkDir(resDir.c_str());

    std::ofstream ofsBonds((resDir + "bonds.txt").c_str());
    std::ofstream ofsEnergy((resDir + "energy.txt").c_str());
    ofsBonds.close();
    ofsEnergy.close();

    fillMendelAndValences();
    std::vector<std::string> files;
    if (!argFile.empty() && core::listFiles(argFile, files) && !files.empty())
    {
        int num = 0;
        for (int i = 0; i < files.size(); ++i)
        {
            const std::string dir = argFile + "/" + files[i];
            const std::string energyList = dir + "/energies";
            if (core::isDir(dir.c_str()) && core::isFileExists(energyList.c_str()))
            {
                std::map<float, std::string> energies;
                std::map<std::string, float> invertedEnergies;
                readEnergies(energyList, energies, invertedEnergies);

//                for (std::map<std::string, float>::iterator it = invertedEnergies.begin();
//                     it != invertedEnergies.end(); ++it)
//                    energies[it->second] = it->first;

                std::ofstream ofs((resDir + "parsed").c_str());
                ofs << "\tName\t\t\t";
                for (std::map<std::string, int>::iterator it = _bonds.begin(); it != _bonds.end(); ++it)
                    ofs << it->first << "\t";
                ofs << "\tEnergy\n";

                std::map<uint, Molecule> molMap;

                // ==========================================================================
                //        const std::string pathToSets("Ca2PO4_PO_bonds");
                //        std::vector<std::vector<std::string> > names;
                //        bool res1 = readSets(pathToSets, names);

                //        if (res1)
                //        {
                //            molMap.clear();
                //            for (int i = 4, size = names.size(); i < size; ++i)
                //            {
                //                std::vector<Molecule> molecules(names[i].size());
                //                for (int j = 0, sizeNames = molecules.size(); j < sizeNames; ++j)
                //                {
                //                    Molecule* mol = &(molecules[j]);
                //                    mol->mPath = names[i][j];
                //                    mol->mName = core::name(mol->mPath);
                //                    mol->mEnergy = invertedEnergies[mol->mName];
                //                    if (readFromFile(*mol))
                //                        fillDistancesAndBonds1(*mol);

                //                    //std::map<uint, Molecule> molMap;
                //                    const uint hash = mol->getHash();
                //                    if (molMap.find(hash) == molMap.end() &&
                //                        10 == mol->getBondsNum())
                //                    molMap[hash] = *mol;
                //                }

                //                writeMolMap(molMap, resDir);


                //                FILE* inRes = fopen("resCoef", "r");
                //                std::vector<float> coefs(_bonds.size() + 1);

                //                for (int i = 0, size = _bonds.size() + 1; i < size; ++i)
                //                    fscanf(inRes, "%f", &(coefs[i]));

                //                if (!coefs.empty())
                //                {
                //                    float RSS = 0.f;
                //                    for (std::map<uint, Molecule>::iterator itMol = molMap.begin();
                //                         itMol != molMap.end(); ++itMol)
                //                    {
                //                        Molecule mol = itMol->second;

                //                        float bondsEnergy = coefs[0];
                //                        int j = 1;
                //                        for (std::map<std::string, int>::iterator it = _bonds.begin();
                //                             it != _bonds.end(); ++it, ++j)
                //                            bondsEnergy += mol.mBonds[it->first] * coefs[j];

                //                        RSS += (mol.mEnergy - bondsEnergy) * (mol.mEnergy - bondsEnergy) / molMap.size();
                //                    }
                //                    std::cout << sqrt(RSS) << std::endl;
                //                }

                //            }

                //        }


                // ==========================================================================

                std::vector<Molecule> molecules(energies.size());
                int ii = 0;
                for (std::map<float, std::string>::iterator it = energies.begin();
                     it != energies.end(); ++it)
                {
                    const std::string name = it->second;
                    Molecule* mol = &(molecules[ii]);
                    mol->mEnergy = it->first;
                    mol->mName = name;
                    mol->mPath = dir + "/" + name + ".xyz";

                    if (readFromFile(*mol))
                    {
                        findDoubleOBond(*mol);
                        fillDistancesAndBonds1(*mol);

                        ofs << mol->mPath << "\t";
                        ++ii;
                        const uint hash = mol->getHash();
                        if (molMap.find(hash) == molMap.end() &&
                                mol->mustBeBonds() == mol->getBondsNum())
                            molMap[hash] = *mol;

                        for (std::map<std::string, int>::iterator it = _bonds.begin();
                             it != _bonds.end(); ++it)
                            ofs << mol->mBonds[it->first] << "\t";

                        ofs << mol->mEnergy << "\n";
                        //ofs << mol.mEnergy << "\n_____________________________________________________________\n";
                    }
                }
                ofs.close();

//                std::ofstream ofsNew((resDir + "new.txt").c_str());
//                for (int j = 0, SIZE = molecules.size();
//                     j < SIZE; ++j)
//                {
//                    Molecule mol1 = molecules[j];
//                    for (int k = j + 1; k < SIZE; ++k)
//                    {
//                        Molecule mol2 = molecules[k];
//                        int bondsDiff = 0;
//                        for (std::map<std::string, int>::iterator it = _bonds.begin();
//                             it != _bonds.end(); ++it)
//                            bondsDiff += fabs(mol1.mBonds[it->first] - mol2.mBonds[it->first]);

//                        ofsNew << bondsDiff << "\t" << fabs(mol1.mEnergy - mol2.mEnergy)
//                               << "\t" << mol1.mName << "\t" << mol2.mName << std::endl;
//                    }
//                }
//                ofsNew.close();

                //writeMolMap(num++, molMap, resDir);

                FILE* inRes = fopen("resCoef", "r");
                std::vector<float> coefs(_bonds.size() + 3);

                for (int i = 0, size = _bonds.size() + 3; i < size; ++i)
                    fscanf(inRes, "%f", &(coefs[i]));

                if (!coefs.empty())
                {
                    float RSS = 0.f;
                    for (std::map<uint, Molecule>::iterator itMol = molMap.begin();
                         itMol != molMap.end(); ++itMol)
                    {
                        Molecule mol = itMol->second;

                        float bondsEnergy = coefs[num];
                        int j = 1;
                        for (std::map<std::string, int>::iterator it = _bonds.begin();
                             it != _bonds.end(); ++it, ++j)
                            bondsEnergy += mol.mBonds[it->first] * coefs[j];

                        RSS += (mol.mEnergy - bondsEnergy) * (mol.mEnergy - bondsEnergy) / molMap.size();
                    }
                    std::cout << sqrt(RSS) << std::endl;
                }
                ++num;
            }
        }

    }

    return 0;
}
