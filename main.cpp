// This will convert results of MOLGEN to many .mol2 files

#include <iostream>
#include <fstream>
#include <stdio.h>
#include <stdlib.h>
#include <iomanip>
#include <string.h>
#include <algorithm>
#include <map>
#include <limits>

#include "Vector3D.h"
#include "Molecule.h"

using namespace phys;

const char* headerLine = "Generated by Molgen 5.0";
const char* endLine = "M  END";

const char* mol2Header1 = "@<TRIPOS>MOLECULE\n*****\n";
const char* mol2Header2 = "SMALL\nGASTEIGER\n";

const char* atomHeader = "@<TRIPOS>ATOM\n";
const char* bondHeader = "@<TRIPOS>BOND\n";

const std::string resCharges("resCharges/");

const char* goodEnd = "M  END";

const char* middlePartAtom = "   1  LIG11   ";

const std::string molecule = "mol_";
const std::string ext = ".mol2";


struct myclass {
  bool operator() (std::pair<std::string, float> i,std::pair<std::string, float> j)
  {
      return (i.second < j.second);
  }

} myobject;

bool parseMolgen(const std::string& path)
{
    bool res = false;
    const int maxSymbols = 200;
    char str[maxSymbols];

    FILE* inFile = fopen(path.c_str(), "r");

    while (inFile != NULL && fgets(str, maxSymbols, inFile))
    {
        if (0 == strncmp(headerLine, str, sizeof(headerLine)))
        {
            core::Time t;
            core::getTime(t);
            std::string timeStr = t.timeString();

            while (core::isFileExists((molecule + timeStr + ext).c_str()))
            {
                ++t;
                timeStr = t.timeString();
            }
            std::string path = molecule + timeStr + ext;

            std::ofstream ofs(path.c_str());
            ofs << mol2Header1;

            //fscanf(inFile, "%d %d", numAtom, numBond)
            fgets(str, maxSymbols, inFile);     // here we have empty line
            fgets(str, maxSymbols, inFile);

            std::istringstream iss(str);
            int numAtom = 0, numBond = 0;
            if ((iss >> numAtom >> numBond) && numAtom > 0 && numBond > 0)
            {
                ofs << " " << numAtom << " " << numBond << " 0 0 0\n";
                ofs << mol2Header2 << "\n" << atomHeader;
                for (int i = 0; i < numAtom; ++i)
                {
                    float x, y, z;
                    std::string atom;
                    fgets(str, maxSymbols, inFile);
                    std::istringstream iss1(str);
                    if ((iss1 >> x >> y >> z >> atom) && !atom.empty())
                        ofs << "\t" << i+1 << "\t" << atom << "\t" << x << "\t" << y << "\t" << z << "\t" << atom << middlePartAtom << "0\n";
                }

                ofs << bondHeader;
                for (int i = 0; i < numBond; ++i)
                {
                    int b, e, mult; // begin, end, multiplicity
                    fgets(str, maxSymbols, inFile);
                    std::istringstream iss1(str);
                    if ((iss1 >> b >> e >> mult) && b > 0 && e > 0 && mult > 0)
                        ofs << "\t" << i+1 << "\t" << b << "\t" << e << "\t" << mult << "\n";
                }
            }
            fgets(str, maxSymbols, inFile);
            res = 0 == strncmp(endLine, str, sizeof(endLine));
            ofs.close();
        }

        //printf("This line = %s", str);
    }

    return res;
}

const std::string divider = "=====";

void readEnergies(const std::string& energyList, std::map<float, std::pair<std::string, float> >& energies,
                  std::vector<std::pair<std::string, float> >& invertedEnergies)
{
    energies.clear();
    invertedEnergies.clear();
    const int maxSymbols = 200;
    char str[maxSymbols];
    FILE* inFile1 = fopen(energyList.c_str(), "r");

    fgets(str, maxSymbols, inFile1);
    while(fgets(str, maxSymbols, inFile1))
    {
         std::istringstream iss(str);
         float energyGibbs = 0.f;
         float firstFreq = 0.f;
         float internalEnergy = 0.f;
         std::string name;
         if ((iss >> name >> energyGibbs >> firstFreq >> internalEnergy) && !name.empty() && firstFreq > 0.f)
         {
//             size_t pose = name.find_last_of(".");
//             name = std::string::npos == pose ? name : std::string(name.begin(), name.begin() + pose);
             energies[energyGibbs] = std::make_pair(name, internalEnergy);
             invertedEnergies.push_back(std::make_pair(name, energyGibbs));
         }
    }

    std::sort(invertedEnergies.begin(), invertedEnergies.end(), myobject);
}

bool readSets(const std::string& path, std::vector<std::vector<std::string> >& sets)
{
    bool res = false;
    sets.clear();
    if (core::isFileExists(path.c_str()))
    {
        std::ifstream ifs(path.c_str());
        std::string name;
        std::vector<std::string> names;
        while (!ifs.eof())
        {
            ifs >> name;
            if (0 == divider.compare(name))
            {
                if (!names.empty())
                    sets.push_back(names);
                names.clear();
            }
            else
                names.push_back(std::string(name));
        }
        res = true;
    }
    return res;
}

bool writeMolMap(const int& num, std::vector<Molecule*>& molMap, const std::string& resDir)
{
    if (!molMap.empty()) {
        std::ofstream ofsBonds((resDir + "bonds.txt").c_str(), std::ios_base::app);
        std::ofstream ofsEnergy((resDir + "energy.txt").c_str(), std::ios_base::app);
        std::ofstream ofsCharges((resDir + "charge.txt").c_str(), std::ios_base::app);
        std::ofstream ofsDist((resDir + "dist.txt").c_str(), std::ios_base::app);

        std::vector<std::vector<int> > bonds;
        std::vector<float> energies;
        for (std::vector<Molecule*>::iterator itMol = molMap.begin();
             itMol != molMap.end(); ++itMol)
        {
            std::vector<int> curBond;
            curBond.push_back(1);

            Molecule* mol = *itMol;
            for (int i = 0; i < mol->mNumAtoms; ++i)
            {
                Atom* atom1 = &mol->mAtoms[i];
                ofsCharges << atom1->mName << "\t" << atom1->mCharge << std::endl;
                for (int j = i + 1; j < mol->mNumAtoms; ++j)
                {
                    Atom* atom2 = &mol->mAtoms[j];
                    float dist = int((atom1->mCoord - atom2->mCoord).Magnitude() * 1000) / 1000.f;
                    std::string name = atom1->Z < atom2->Z ? atom1->mName + atom2->mName : atom2->mName + atom1->mName;
                    ofsDist << name << "\t" << dist << std::endl;
                }
            }

            ofsEnergy << mol->mEnergy << std::endl;

//            ofsBonds << "1\t";
            switch (num)
            {
            case 0:
                ofsBonds << "1\t0\t0\t0\t";
                break;
            case 1:
                ofsBonds << "0\t1\t0\t0\t";
                break;
            case 2:
                ofsBonds << "0\t0\t1\t0\t";
                break;
            case 3:
                ofsBonds << "0\t0\t0\t1\t";
                break;
            }

            for (std::set<std::string>::iterator it = _bonds.begin();
                 it != _bonds.end(); ++it)
                if (*it != "ionCa" && *it != "combo" && *it != "O1P^2" && *it != "O1P^3")
                {
                    curBond.push_back(mol->mBonds[*it]);
                    ofsBonds << mol->mBonds[*it] << "\t";
                }
            ofsBonds << std::endl;
            bonds.push_back(curBond);
            energies.push_back(mol->mEnergy);
            //ofsBonds << mol->mP_Charge << std::endl;
        }

//        ofsBonds << "______________________\n______________________\n______________________\n";
//        ofsEnergy << "______________________\n______________________\n______________________\n";
//        for (uint j = 0; j < bonds[0].size(); ++j)
//        {
//            float energy(0.f);
//            for (int k = 0; k < bonds[j].size(); ++k)
//            {
//                int ggg = 0;
//                for (int i = 0; i < molMap.size(); ++i)
//                {
//                    energy += energies[i] * bonds[i][j];
//                    ggg += bonds[i][k] * bonds[i][j];
//                }
//                ofsBonds << ggg << "\t";
//            }
//            ofsBonds << std::endl;
//            ofsEnergy << energy / (float)bonds[j].size() << std::endl;
//        }

        ofsBonds.close();
        ofsEnergy.close();
        ofsCharges.close();
        ofsDist.close();

        return true;
    }
    return false;
}

void checkingApproximation()    // not work properly
{
    const std::string dir = "Results/";
    srand(time(NULL));
    const int size = 18;
//    std::ofstream ofsCoef("resCoef");
//    std::vector<int> coefs(size, 0);
//    for (int i = 0; i < size; ++i)
//    {
//        coefs[i] = rand() % 2000 - 1000;
//        ofsCoef << coefs[i] << "\n";
//    }
//    ofsCoef.close();

    FILE* inRes = fopen("resCoef", "r");
    std::vector<float> coefs(size);

    for (int iii = 0; iii < size; ++iii)
        fscanf(inRes, "%f", &(coefs[iii]));
    
    const uint numEquations = 10;
    std::vector<ull> equations;

//    std::cout << std::numeric_limits<ull>::min() << "\n" << 
//                 std::numeric_limits<ull>::max() << std::endl;

    FILE* inBond = fopen((dir + "bonds.txt").c_str(), "r");
    FILE* inEnergy = fopen((dir + "energy.txt").c_str(), "r");
    assert(inBond != NULL);
    assert(inEnergy != NULL);
    int bond = 0;

    int k = 0;
    while (k++ < numEquations)
    {
        float energy(0.f);
        float energyStandard(0.f);
        for (int i = 3; i < numEquations; ++i)
        {
            fscanf(inBond, "%d", &bond);
            energy += bond * coefs[i];
        }
        energy += coefs[0];
        fscanf(inEnergy, "%f", &energyStandard);

        std::cout << energyStandard << "\t\t" << energy << std::endl;

        ull N = 0;
        int numBonds = 0;
        for (int i = 0; i < size; ++i)
        {
            int curbond = rand() % 3;
            numBonds += curbond;
            N = N * 10 + curbond;
        }

        if (equations.end() == std::find(equations.begin(), equations.end(), N))
            equations.push_back(N);
    }

    std::ofstream ofsEnergy("energy.txt");
    std::ofstream ofsBonds("bonds.txt");
    std::vector<int> energies(numEquations, 0);
    for (uint i = 0; i < numEquations; ++i)
    {
        ull k = equations[i];
        uint j = 0;
        while (k != 0)
        {
            int res = k % 10;
            energies[i] += res * coefs[j++];
            k /= 10;
            ofsBonds << res << "\t";
        }

        while (j++ < coefs.size())
            ofsBonds << "0\t";

        ofsBonds << std::endl;
        ofsEnergy << energies[i] << std::endl;
    }
    ofsBonds.close();
    ofsEnergy.close();
}

int main(int argc, char* argv[])
{
    std::string argFile;
    bool excludeCa = false;
    if (argc > 1)
    {
        for (int i = 0; i < argc; ++i)
        {
            const char* param = argv[i];
            if (0 == strncmp(param, "-in=", 4))
                argFile = param + 4;
            if (0 == strncmp(param, "-excludeCa", 10))
                excludeCa = true;
        }
    }

    //checkingApproximation();

    std::string resDir = "Results/";
    if (!core::isDir(resDir.c_str()))
        core::mkDir(resDir.c_str());

    std::ofstream ofsBonds((resDir + "bonds.txt").c_str());
    std::ofstream ofsEnergy((resDir + "energy.txt").c_str());
    std::ofstream ofsCharges((resDir + "charge.txt").c_str());
    std::ofstream ofsDist((resDir + "dist.txt").c_str());
    ofsCharges.close();
    ofsBonds.close();
    ofsEnergy.close();
    ofsDist.close();

    fillMendelAndValences();
    std::vector<std::string> files;
    if (!argFile.empty() && core::listFiles(argFile, files) && !files.empty())
    {
        int num = 0;
        std::map<int, std::pair<int, float> > allCharges;
        std::ofstream ofsDuplicates((resDir + "duplicates.txt").c_str());
        std::ofstream ofsUnique((resDir + "unique.txt").c_str());

        std::ofstream ofs((resDir + "parsed").c_str());
        ofs << "Name\t\t";
        for (std::set<std::string>::iterator it = _bonds.begin(); it != _bonds.end(); ++it)
            ofs << *it << "\t";
        ofs << "P_cahrge\tionEnergy\tRealGibbsEnergy\tRealInternalEnergy\tEapprox\n";

        std::ofstream ofsNum((resDir + "num.txt").c_str());
        uint glob(0), geom(0), depth(0);

        const int numSets = 4;
        FILE* inRes = fopen("resCoef", "r");
        std::vector<float> coefs(_bonds.size() + numSets - 1, 0.f);     // -1 cause "ionCa"

        for (int iii = 0, size = _bonds.size() + numSets; iii < size; ++iii)
            fscanf(inRes, "%f", &(coefs[iii]));

        for (uint i = 0; i < files.size(); ++i)
        {
            const std::string dir = argFile + "/" + files[i];
            const std::string energyList = dir + "/energies";
            if (core::isDir(dir.c_str()) && core::isFileExists(energyList.c_str()))
            {
                std::map<float, std::pair<std::string, float> > energies;
                std::vector<std::pair<std::string, float> > invertedEnergies;
                readEnergies(energyList, energies, invertedEnergies);

//                for (std::map<std::string, float>::iterator it = invertedEnergies.begin();
//                     it != invertedEnergies.end(); ++it)
//                    energies[it->second] = it->first;

                std::vector<Molecule*> molMap;
                std::set<uint> params;

                std::vector<Molecule> molecules(invertedEnergies.size(), Molecule());
                int ii = 0;
                for (std::vector<std::pair<std::string, float> >::iterator it = invertedEnergies.begin();
                     it != invertedEnergies.end(); ++it)
                {
                    const std::string name = it->first;
                    Molecule* mol = &(molecules[ii]);
                    mol->mEnergy = it->second;
                    mol->mInernalEnergy = it->second;
                    mol->mName = name;
                    mol->mPath = dir + "/" + name + ".xyz";
                    ++glob;

                    if (mol->readFromFile() && params.end() == params.find(mol->param))
                    {
                        ++geom;
                        params.insert(mol->param);
                        mol->setNumAtoms();
                        const std::string pathCharges = argFile + "/" + resCharges + mol->mName + ".xyz.out";
                        mol->readCharges(pathCharges);
                        mol->fillDistancesAndBonds1();
                        bool res = true;
                        int k = 0;
                        for (; k < ii && res; k++)
                            res = !mol->equal(molecules[k]);

                        if (!res)
                        {
                            ofsDuplicates << mol->mName << "\t\t" << molecules[k-1].mName << std::endl;
                            ofsDuplicates << mol->mEnergy << "\t\t\t" << molecules[k-1].mEnergy << std::endl;
                            ofsDuplicates << "___________________________________________\n\n";
                        }

                        if (fabs(mol->mP_Charge) > 0.001f && mol->isCoherent() && res)
                        {
                            ++depth;
                            ofsUnique << mol->mName << std::endl;
                            if (excludeCa)
                                mol->excludeCa();
//                             mol->writeGaussianFile();
                            mol->fillChargesStat(allCharges);

                            float bondsEnergy = coefs[num];
                            int j = numSets;
                            for (std::set<std::string>::iterator it = _bonds.begin();
                                 it != _bonds.end(); ++it, ++j)
                            {
                                const float numBonds = mol->mBonds[*it];
                                bondsEnergy += numBonds * coefs[j];
                            }
                            std::cout << mol->mEnergy << "\t\t" << bondsEnergy << std::endl;

                            ofs << mol->mName << "\t";
                            const ull hash = mol->getHash();
                            molMap.push_back(mol);
//                            const uint mustBeBonds = mol->mustBeBonds();
//                            const uint getBondsNum = mol->getBondsNum();
//                            if (molMap.find(hash) == molMap.end())
//                                molMap[hash] = mol;

                            for (std::set<std::string>::iterator it = _bonds.begin();
                                 it != _bonds.end(); ++it)
                                ofs << mol->mBonds[*it] << "\t";

                            ofs << mol->mP_Charge << "\t" << mol->mIonEnergy << "\t" << mol->mEnergy << "\t\t" << mol->mInernalEnergy << "\t\t" << bondsEnergy << std::endl;
                            //ofs << mol.mEnergy << "\n_____________________________________________________________\n";
                        }
                        else
                            std::cout << "Bad complex = " << mol->mPath << std::endl;

                        ++ii;
                    }
                }

                std::cout << ii << "\tof\t" << molecules.size() << std::endl;
                std::cout << "_____________________\n________________\n";

//                std::ofstream ofsNew((resDir + "new.txt").c_str());
//                for (int j = 0, SIZE = molecules.size();
//                     j < SIZE; ++j)
//                {
//                    Molecule mol1 = molecules[j];
//                    for (int k = j + 1; k < SIZE; ++k)
//                    {
//                        Molecule mol2 = molecules[k];
//                        int bondsDiff = 0;
//                        for (std::map<std::string, int>::iterator it = _bonds.begin();
//                             it != _bonds.end(); ++it)
//                            bondsDiff += fabs(mol1.mBonds[it->first] - mol2.mBonds[it->first]);

//                        ofsNew << bondsDiff << "\t" << fabs(mol1.mEnergy - mol2.mEnergy)
//                               << "\t" << mol1.mName << "\t" << mol2.mName << std::endl;
//                    }
//                }
//                ofsNew.close();

                writeMolMap(num, molMap, resDir);
                //ofs.close();
                //ofsDuplicates.close();

                ++num;
                ofsNum << "glob = " << glob << "\ngeom = " << geom << "\ndepth = " << depth << std::endl;
                ofsDuplicates << "+++++++++++++++++++++++++++++++++++++++\n";
                ofsUnique << "+++++++++++++++++++++++++++++++++++++++\n";
            }
        }

        ofs.close();
        ofsUnique.close();
        ofsDuplicates.close();

        if (!allCharges.empty())
        {
            std::ofstream ofsCharge("resCharges");
            for (std::map<int, std::pair<int, float> >::iterator it = allCharges.begin();
                 it != allCharges.end(); ++it)
            {
                ofsCharge << "Z = " << it->first << "\t";
                ofsCharge << it->second.second / it->second.first << std::endl;
            }

        }
    }

    return 0;
}
