// This will convert results of MOLGEN to many .mol2 files

#include <iostream>
#include <fstream>
#include <stdio.h>
#include <stdlib.h>
#include <iomanip>
#include <string.h>
#include <algorithm>
#include <map>
#include <matrix.h>
#include <limits>

#include "Vector3D.h"
#include "Molecule.h"

using namespace phys;

const char* headerLine = "Generated by Molgen 5.0";
const char* endLine = "M  END";

const char* mol2Header1 = "@<TRIPOS>MOLECULE\n*****\n";
const char* mol2Header2 = "SMALL\nGASTEIGER\n";

const char* atomHeader = "@<TRIPOS>ATOM\n";
const char* bondHeader = "@<TRIPOS>BOND\n";

const std::string resCharges("resCharges/");

const char* goodEnd = "M  END";

const char* middlePartAtom = "   1  LIG11   ";

const std::string molecule = "mol_";
const std::string ext = ".mol2";

bool parseMolgen(const std::string& path)
{
    bool res = false;
    const int maxSymbols = 200;
    char str[maxSymbols];

    FILE* inFile = fopen(path.c_str(), "r");

    while (inFile != NULL && fgets(str, maxSymbols, inFile))
    {
        if (0 == strncmp(headerLine, str, sizeof(headerLine)))
        {
            core::Time t;
            core::getTime(t);
            std::string timeStr = t.timeString();

            while (core::isFileExists((molecule + timeStr + ext).c_str()))
            {
                ++t;
                timeStr = t.timeString();
            }
            std::string path = molecule + timeStr + ext;

            std::ofstream ofs(path.c_str());
            ofs << mol2Header1;

            //fscanf(inFile, "%d %d", numAtom, numBond)
            fgets(str, maxSymbols, inFile);     // here we have empty line
            fgets(str, maxSymbols, inFile);

            std::istringstream iss(str);
            int numAtom = 0, numBond = 0;
            if ((iss >> numAtom >> numBond) && numAtom > 0 && numBond > 0)
            {
                ofs << " " << numAtom << " " << numBond << " 0 0 0\n";
                ofs << mol2Header2 << "\n" << atomHeader;
                for (int i = 0; i < numAtom; ++i)
                {
                    float x, y, z;
                    std::string atom;
                    fgets(str, maxSymbols, inFile);
                    std::istringstream iss1(str);
                    if ((iss1 >> x >> y >> z >> atom) && !atom.empty())
                        ofs << "\t" << i+1 << "\t" << atom << "\t" << x << "\t" << y << "\t" << z << "\t" << atom << middlePartAtom << "0\n";
                }

                ofs << bondHeader;
                for (int i = 0; i < numBond; ++i)
                {
                    int b, e, mult; // begin, end, multiplicity
                    fgets(str, maxSymbols, inFile);
                    std::istringstream iss1(str);
                    if ((iss1 >> b >> e >> mult) && b > 0 && e > 0 && mult > 0)
                        ofs << "\t" << i+1 << "\t" << b << "\t" << e << "\t" << mult << "\n";
                }
            }
            fgets(str, maxSymbols, inFile);
            res = 0 == strncmp(endLine, str, sizeof(endLine));
            ofs.close();
        }

        //printf("This line = %s", str);
    }

    return res;
}


const std::string divider = "=====";

void readEnergies(const std::string& energyList, std::map<float, std::string>& energies,
                  std::map<std::string, float>& invertedEnergies)
{
    energies.clear();
    invertedEnergies.clear();
    const int maxSymbols = 200;
    char str[maxSymbols];
    FILE* inFile1 = fopen(energyList.c_str(), "r");

    while(fgets(str, maxSymbols, inFile1))
    {
         std::istringstream iss(str);
         float energy = 0.f;
         float firstFreq = 0.f;
         std::string name;
         if ((iss >> name >> energy >> firstFreq) && !name.empty() && firstFreq > 0.f)
         {
             size_t pose = name.find_first_of(".");
             name = std::string::npos == pose ? name : std::string(name.begin(), name.begin() + pose);
             energies[energy] = name;
             invertedEnergies[name] = energy;
         }
    }
}

bool readSets(const std::string& path, std::vector<std::vector<std::string> >& sets)
{
    bool res = false;
    sets.clear();
    if (core::isFileExists(path.c_str()))
    {
        std::ifstream ifs(path.c_str());
        std::string name;
        std::vector<std::string> names;
        while (!ifs.eof())
        {
            ifs >> name;
            if (0 == divider.compare(name))
            {
                if (!names.empty())
                    sets.push_back(names);
                names.clear();
            }
            else
                names.push_back(std::string(name));
        }
        res = true;
    }
    return res;
}

bool writeMolMap(const int& num, std::map<ull, Molecule*>& molMap, const std::string& resDir)
{
    if (!molMap.empty()) {
        int i = 0;

        std::ofstream ofsBonds((resDir + "bonds.txt").c_str(), std::ios_base::app);
        std::ofstream ofsEnergy((resDir + "energy.txt").c_str(), std::ios_base::app);

        for (std::map<ull, Molecule*>::iterator itMol = molMap.begin();
             itMol != molMap.end(); ++itMol, ++i)
        {
            Molecule* mol = itMol->second;
            ofsEnergy << mol->mEnergy << std::endl;

            int j = 1;
            switch (num)
            {
            case 0:
                ofsBonds << "1\t0\t0\t";
                break;
            case 1:
                ofsBonds << "0\t1\t0\t";
                break;
            case 2:
                ofsBonds << "0\t0\t1\t";
                break;
            }

            for (std::set<std::string>::iterator it = _bonds.begin();
                 it != _bonds.end(); ++it, ++j)
                ofsBonds << mol->mBonds[*it] << "\t";
            ofsBonds << std::endl;
        }

        ofsBonds.close();
        ofsEnergy.close();
        return true;
    }
    return false;
}

void checkingApproximation()
{
    srand(time(NULL));
    const int size = 18;
    std::ofstream ofsCoef("resCoef.txt");
    std::vector<int> coefs(size, 0);
    for (int i = 0; i < size; ++i)
    {
        coefs[i] = rand() % 2000 - 1000;
        ofsCoef << coefs[i] << "\n";
    }
    ofsCoef.close();

    const uint numEquations = 40;
    std::vector<ull> equations;

    std::cout << std::numeric_limits<ull>::min() << "\n" << 
                 std::numeric_limits<ull>::max() << std::endl;

    while (equations.size() != numEquations)
    {
        ull N = 0;
        int numBonds = 0;
        for (int i = 0; i < size; ++i)
        {
            int curbond = rand() % 3;
            numBonds += curbond;
            N = N * 10 + curbond;
        }

        if (equations.end() == std::find(equations.begin(), equations.end(), N))
            equations.push_back(N);
    }

    std::ofstream ofsEnergy("energy.txt");
    std::ofstream ofsBonds("bonds.txt");
    std::vector<int> energies(numEquations, 0);
    for (uint i = 0; i < numEquations; ++i)
    {
        ull k = equations[i];
        uint j = 0;
        while (k != 0)
        {
            int res = k % 10;
            energies[i] += res * coefs[j++];
            k /= 10;
            ofsBonds << res << "\t";
        }

        while (j++ < coefs.size())
            ofsBonds << "0\t";

        ofsBonds << std::endl;
        ofsEnergy << energies[i] << std::endl;
    }
    ofsBonds.close();
    ofsEnergy.close();
}

int main(int argc, char* argv[])
{
    std::string argFile;
    bool excludeCa = false;
    if (argc > 1)
    {
        for (int i = 0; i < argc; ++i)
        {
            const char* param = argv[i];
            if (0 == strncmp(param, "-in=", 4))
                argFile = param + 4;
            if (0 == strncmp(param, "-excludeCa", 10))
                excludeCa = true;
        }
    }

    std::string resDir = argFile + "/Results/";
    if (!core::isDir(resDir.c_str()))
        core::mkDir(resDir.c_str());

    std::ofstream ofsBonds((resDir + "bonds.txt").c_str());
    std::ofstream ofsEnergy((resDir + "energy.txt").c_str());
    ofsBonds.close();
    ofsEnergy.close();

    fillMendelAndValences();
    std::vector<std::string> files;
    if (!argFile.empty() && core::listFiles(argFile, files) && !files.empty())
    {
        int num = 0;
        std::map<int, std::pair<int, float> > allCharges;
        for (uint i = 0; i < files.size(); ++i)
        {
            const std::string dir = argFile + "/" + files[i];
            const std::string energyList = dir + "/energies";
            if (core::isDir(dir.c_str()) && core::isFileExists(energyList.c_str()))
            {
                std::map<float, std::string> energies;
                std::map<std::string, float> invertedEnergies;
                readEnergies(energyList, energies, invertedEnergies);

//                for (std::map<std::string, float>::iterator it = invertedEnergies.begin();
//                     it != invertedEnergies.end(); ++it)
//                    energies[it->second] = it->first;

                std::ofstream ofs((resDir + "parsed").c_str());
                ofs << "\tName\t\t\t";
                for (std::set<std::string>::iterator it = _bonds.begin(); it != _bonds.end(); ++it)
                    ofs << *it << "\t";
                ofs << "\tEnergy\n";

                std::map<ull, Molecule*> molMap;

                std::vector<Molecule> molecules(energies.size(), Molecule());
                int ii = 0;
                for (std::map<float, std::string>::iterator it = energies.begin();
                     it != energies.end(); ++it)
                {
                    const std::string name = it->second;
                    Molecule* mol = &(molecules[ii]);
                    mol->mEnergy = it->first;
                    mol->mName = name;
                    mol->mPath = dir + "/" + name + ".xyz";

                    if (mol->readFromFile())
                    {
                        mol->setNumAtoms();
                        const std::string pathCharges = argFile + "/" + resCharges + mol->mName + ".xyz.out";
                        mol->readCharges(pathCharges);
                        mol->fillDistancesAndBonds1();

                        if (mol->isCoherent())
                        {
                            if (excludeCa)
                                mol->excludeCa();
                            // mol->writeGaussianFile();
                            mol->fillChargesStat(allCharges);
                            ofs << mol->mPath << "\t";
                            const ull hash = mol->getHash();
//                            const uint mustBeBonds = mol->mustBeBonds();
//                            const uint getBondsNum = mol->getBondsNum();
                            if (molMap.find(hash) == molMap.end())
                                molMap[hash] = mol;

                            for (std::set<std::string>::iterator it = _bonds.begin();
                                 it != _bonds.end(); ++it)
                                ofs << mol->mBonds[*it] << "\t";

                            ofs << mol->mEnergy << "\n";
                            //ofs << mol.mEnergy << "\n_____________________________________________________________\n";
                        }
                        else
                            std::cout << "Bad complex = " << mol->mPath << std::endl;

                        ++ii;
                    }
                }
                ofs.close();
                std::cout << ii << "\tof\t" << molecules.size() << std::endl;
                std::cout << "_____________________\n________________\n";

//                std::ofstream ofsNew((resDir + "new.txt").c_str());
//                for (int j = 0, SIZE = molecules.size();
//                     j < SIZE; ++j)
//                {
//                    Molecule mol1 = molecules[j];
//                    for (int k = j + 1; k < SIZE; ++k)
//                    {
//                        Molecule mol2 = molecules[k];
//                        int bondsDiff = 0;
//                        for (std::map<std::string, int>::iterator it = _bonds.begin();
//                             it != _bonds.end(); ++it)
//                            bondsDiff += fabs(mol1.mBonds[it->first] - mol2.mBonds[it->first]);

//                        ofsNew << bondsDiff << "\t" << fabs(mol1.mEnergy - mol2.mEnergy)
//                               << "\t" << mol1.mName << "\t" << mol2.mName << std::endl;
//                    }
//                }
//                ofsNew.close();

                //writeMolMap(num, molMap, resDir);

                if (true)
                {
                    const int numSets = 3;
                    FILE* inRes = fopen("resCoef", "r");
                    std::vector<float> coefs(_bonds.size() + numSets);

                    for (int i = 0, size = _bonds.size() + numSets; i < size; ++i)
                        fscanf(inRes, "%f", &(coefs[i]));

                    if (!coefs.empty())
                    {
                        float RSS = 0.f;
                        for (std::map<ull, Molecule*>::iterator itMol = molMap.begin();
                             itMol != molMap.end(); ++itMol)
                        {
                            Molecule* mol = itMol->second;

                            float bondsEnergy = coefs[num];
                            int j = numSets;
                            for (std::set<std::string>::iterator it = _bonds.begin();
                                 it != _bonds.end(); ++it, ++j)
                            {
                                const float numBonds = mol->mBonds[*it];
                                bondsEnergy += numBonds * coefs[j];
                            }

                            const float diff = mol->mEnergy - bondsEnergy;
                            RSS += diff * diff / molMap.size();
                        }
                        std::cout << sqrt(RSS) << std::endl;
                        std::cout << "_____________________\n\n";
                    }
                }
                ++num;
            }
        }

        if (!allCharges.empty())
        {
            std::ofstream ofsCharge("resCharges");
            for (std::map<int, std::pair<int, float> >::iterator it = allCharges.begin();
                 it != allCharges.end(); ++it)
            {
                ofsCharge << "Z = " << it->first << "\t";
                ofsCharge << it->second.second / it->second.first << std::endl;
            }

        }
    }

    return 0;
}
