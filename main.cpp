// This will convert results of MOLGEN to many .mol2 files

#include <iostream>
#include <sstream>
#include <fstream>
#include <stdio.h>
#include <iomanip>
#include <string.h>
#include <vector>
#include <map>
#include <dirent.h>
#include <time.h>
#include <sys/stat.h>

#include "Vector3D.h"
//#include <sysUtils.h>

const char* headerLine = "Generated by Molgen 5.0";
const char* endLine = "M  END";

const char* mol2Header1 = "@<TRIPOS>MOLECULE\n*****\n";
const char* mol2Header2 = "SMALL\nGASTEIGER\n";

const char* atomHeader = "@<TRIPOS>ATOM\n";
const char* bondHeader = "@<TRIPOS>BOND\n";

const char* goodEnd = "M  END";

const char* middlePartAtom = "   1  LIG11   ";

const std::string molecule = "mol_";
const std::string ext = ".mol2";

template <class T>
std::string to_string(T value)
{
    std::stringstream ss;
    ss << value;
    std::string str;
    ss >> str;
    return str;
}

namespace core
{
    struct time
    {
        short sec;
        short min;
        short hour;
        short day;
        short month;
        short year;

        time()  {}

        std::string timeString()
        {
            return to_string(hour) + "." +
                   to_string(min) + "." +
                   to_string(sec);
        }

        void operator++()
        {
            if (++sec > 59)
            {
                sec = 0;
                if (++min > 59)
                {
                    min = 0;
                    if (++hour > 23)
                        hour = 0;
                }

            }
        }
    };

    std::string getExt(const std::string& path)
    {
        size_t pose = path.find_last_of(".");
        if (std::string::npos == pose)
            return path;
        return std::string(path.begin() + pose + 1, path.end());
    }

    bool isFileExists(const char* path)
    {
        struct stat buffer;
        return (stat (path, &buffer) == 0); 
    }

    bool isDir(const char* path)
    {
        struct stat sb;
        return stat(path, &sb) == 0 && S_ISDIR(sb.st_mode);
    }

    bool mkDir(const char* path)
    {
        return !isDir(path) ?
            mkdir(path, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) :
            false;
    }

    bool listFiles(const std::string& path, std::vector<std::string>& files)
    {
        files.clear();
        DIR *dir;
        struct dirent *ent;
        if ((dir = opendir (path.c_str())) != NULL)
        {
            /* print all the files and directories within directory */
            while ((ent = readdir (dir)) != NULL)
            {
                if (strncmp(ent->d_name, ".", 1) == 0 ||
                    strncmp(ent->d_name, "..", 2) == 0)
                    continue;
                files.push_back(std::string(ent->d_name));
            }
            closedir (dir);
            return true;
        }
        else
        {
          /* could not open directory */
          perror ("");
          return false;
        }
    }

    std::string nameWithExt(const std::string& path)
    {
        size_t pose = path.find_last_of("\\/");
        if (std::string::npos == pose)
            return path;
        return std::string(path.begin() + pose + 1, path.end());
    }

    std::string name(const std::string& path)
    {
        size_t pose1 = path.find_last_of("\\/");
        size_t pose2 = path.find_last_of(".");
        if (std::string::npos == pose1)
            return (std::string::npos == pose2) ? path : std::string(path.begin(), path.begin() + pose2);

        return std::string(path.begin() + pose1 + 1, path.begin() + pose2);
    }
};

void getTime(core::time& t)
{
    time_t rawtime;
    struct tm  *timeinfo;

    time (&rawtime);
    timeinfo = localtime(&rawtime);

    t.sec = timeinfo->tm_sec;
    t.min = timeinfo->tm_min;
    t.hour = timeinfo->tm_hour;

    t.day = timeinfo->tm_mday;
    t.month = timeinfo->tm_mon + 1;
    t.year = 1900 + timeinfo->tm_year;
}

std::string getTime()
{
    time_t rawtime;
    struct tm  *timeinfo;
    char buffer[80];

    time (&rawtime);
    timeinfo = localtime(&rawtime);

    //strftime(buffer, 80, "%I.%M.%S", timeinfo);
    strftime(buffer, 80, "%d-%m-%Y %I:%M:%S", timeinfo);
    //std::string str = std::string(timeinfo->tm_hour) + "." + std::string(timeinfo->tm_min) + "." + std::string(timeinfo->tm_sec);
    std::string str(buffer);

    std::string newstr(str.begin() + 11, str.end());
    int pos = newstr.find_last_of(":");
    newstr[pos] = '.';
    pos = newstr.find_last_of(":");
    newstr[pos] = '.';
    //std::cout << newstr << std::endl;
    return newstr;

    //return str;
}

bool parseMolgen(const std::string& path)
{
    bool res = false;
    const int maxSymbols = 200;
    char str[maxSymbols];

    FILE* inFile = fopen(path.c_str(), "r");

    while (inFile != NULL && fgets(str, maxSymbols, inFile))
    {
        if (0 == strncmp(headerLine, str, sizeof(headerLine)))
        {
            core::time t;
            getTime(t);
            std::string timeStr = t.timeString();

            while (core::isFileExists((molecule + timeStr + ext).c_str()))
            {
                ++t;
                timeStr = t.timeString();
            }
            std::string path = molecule + timeStr + ext;

            std::ofstream ofs(path.c_str());
            ofs << mol2Header1;

            //fscanf(inFile, "%d %d", numAtom, numBond)
            fgets(str, maxSymbols, inFile);     // here we have empty line
            fgets(str, maxSymbols, inFile);

            std::istringstream iss(str);
            int numAtom = 0, numBond = 0;
            if ((iss >> numAtom >> numBond) && numAtom > 0 && numBond > 0)
            {
                ofs << " " << numAtom << " " << numBond << " 0 0 0\n";
                ofs << mol2Header2 << "\n" << atomHeader;
                for (int i = 0; i < numAtom; ++i)
                {
                    float x, y, z;
                    std::string atom;
                    fgets(str, maxSymbols, inFile);
                    std::istringstream iss1(str);
                    if ((iss1 >> x >> y >> z >> atom) && !atom.empty())
                        ofs << "\t" << i+1 << "\t" << atom << "\t" << x << "\t" << y << "\t" << z << "\t" << atom << middlePartAtom << "0\n";
                }

                ofs << bondHeader;
                for (int i = 0; i < numBond; ++i)
                {
                    int b, e, mult; // begin, end, multiplicity
                    fgets(str, maxSymbols, inFile);
                    std::istringstream iss1(str);
                    if ((iss1 >> b >> e >> mult) && b > 0 && e > 0 && mult > 0)
                        ofs << "\t" << i+1 << "\t" << b << "\t" << e << "\t" << mult << "\n";
                }
            }
            fgets(str, maxSymbols, inFile);
            res = 0 == strncmp(endLine, str, sizeof(endLine));
            ofs.close();
        }

        //printf("This line = %s", str);
    }

    return res;
}


// map: first - name, second - atom mass
std::map<std::string, int> mendel;
// map: first - name, second - valence
std::map<std::string, int> valences;
// map: first - bond, second - num;
std::map<std::string, int> _bonds;

const std::string resFile_HO = "resFile_HO";
const std::string resFile_HCa = "resFile_HCa";
const std::string resFile_HP = "resFile_HP";
const std::string resFile_OO = "resFile_OO";
const std::string resFile_OP = "resFile_OP";
const std::string resFile_OCa = "resFile_OCa";
const std::string resFile_PP = "resFile_PP";
const std::string resFile_PCa = "resFile_PCa";
const std::string resFile_CaCa = "resFile_CaCa";

void fillMendelAndValences()
{
    mendel["H"] = 1;
    mendel["O"] = 16;
    mendel["P"] = 31;
    mendel["Ca"] = 40;

    valences["H"] = 1;
    valences["O"] = 2;
    valences["P"] = 5;
    valences["Ca"] = 2;

    int i = 0;
    _bonds["HO"] = ++i;
    _bonds["HCa"] = ++i;
    _bonds["HP"] = ++i;
    _bonds["OO"] = ++i;
    _bonds["OP"] = ++i;
    _bonds["OCa"] = ++i;
    _bonds["PP"] = ++i;
    _bonds["PCa"] = ++i;
    _bonds["CaCa"] = ++i;

    std::ofstream outfile(resFile_HO.c_str());
    outfile << resFile_HO << std::endl;
    outfile.close();

    std::ofstream outfile1(resFile_HCa.c_str());
    outfile1 << resFile_HCa << std::endl;
    outfile1.close();

//    std::ofstream outfile2(resFile_HO.c_str());
//    outfile2 << resFile_HO << std::endl;
//    outfile2.close();

    std::ofstream outfile3(resFile_HP.c_str());
    outfile3 << resFile_HP << std::endl;
    outfile3.close();

    std::ofstream outfile4(resFile_OO.c_str());
    outfile4 << resFile_OO << std::endl;
    outfile4.close();

    std::ofstream  outfile5(resFile_OP.c_str());
    outfile5 << resFile_OP << std::endl;
    outfile5.close();
    
    std::ofstream outfile6(resFile_CaCa.c_str());
    outfile6 << resFile_CaCa << std::endl;
    outfile6.close();

    std::ofstream outfile7(resFile_PP.c_str());
    outfile << resFile_PP << std::endl;
    outfile.close();

    std::ofstream outfile8(resFile_PCa.c_str());
    outfile << resFile_PCa << std::endl;
    outfile.close();

    std::ofstream outfile9(resFile_CaCa.c_str());
    outfile << resFile_CaCa << std::endl;
    outfile.close();
}

struct Atom
{
    std::string mName;
    Vector3D mCoord;
};

struct Molecule
{
    std::vector<Atom> mAtoms;
    std::string mName;
    float mEnergy;
};

// Fill distances files and bonds 
void fillDistancesAndBonds(const Molecule& mol, std::ofstream& ofs)
{

    std::map<std::string, int> bonds;       // num bonds in molecule
    const int size = mol.mAtoms.size();
    
    std::vector< std::vector<char> > matrixBonds;
    std::vector<char> tmp(size, 0);
    for (int i = 0; i < size; ++i)
        matrixBonds.push_back(tmp);


    std::map<std::pair<std::string,int>, int> binding;     // respond to current binding in molecule

    for (int i = 0; i < size; ++i)
    {
        Atom atom1 = mol.mAtoms[i];
        std::string s1 = atom1.mName;
        std::map<float, std::pair<std::string, int> > distances; // to another atoms
        for (int j = i + 1; j < size; ++j)
        {
            Atom atom2 = mol.mAtoms[j];
            std::string s2 = atom2.mName;
            
            float magnitude = int(1000 * Magnitude(atom1.mCoord - atom2.mCoord)) / 1000.f;
            distances[magnitude] = std::make_pair(s2, j);
            
            switch (mendel[s1] * mendel[s2])
            {
                // HO = 1 * 16
                case 16:
                {
                    std::ofstream outfile(resFile_HO.c_str(), std::ios_base::app);
                    outfile << magnitude << std::endl;
                    outfile.close();
                }
                // HCa = 1 * 40
                case 40:
                {
                    std::ofstream outfile(resFile_HCa.c_str(), std::ios_base::app);
                    outfile << magnitude << std::endl;
                    outfile.close();
                }
                // HP
                case 31:
                {
                    std::ofstream outfile(resFile_HP.c_str(), std::ios_base::app);
                    outfile << magnitude << std::endl;
                    outfile.close();
                }
                // OO
                case 256:
                {
                    std::ofstream outfile(resFile_OO.c_str(), std::ios_base::app);
                    outfile << magnitude << std::endl;
                    outfile.close();
                }
                // OP
                case 496:
                {
                    std::ofstream outfile(resFile_OP.c_str(), std::ios_base::app);
                    outfile << magnitude << std::endl;
                    outfile.close();
                }
                // OCa
                case 640:
                {
                    std::ofstream outfile(resFile_OCa.c_str(), std::ios_base::app);
                    outfile << magnitude << std::endl;
                    outfile.close();
                }
                // PP
                case 961:
                {
                    std::ofstream outfile(resFile_PP.c_str(), std::ios_base::app);
                    outfile << magnitude << std::endl;
                    outfile.close();
                }
                // PCa
                case 1240:
                {
                    std::ofstream outfile(resFile_PCa.c_str(), std::ios_base::app);
                    outfile << magnitude << std::endl;
                    outfile.close();
                }
                // CaCa
                case 1600:
                {
                    std::ofstream outfile(resFile_CaCa.c_str(), std::ios_base::app);
                    outfile << magnitude << std::endl;
                    outfile.close();
                }
            }
        }
        
        int v = 0,
            valence = valences[s1];
        for (std::map<float, std::pair<std::string, int> >::iterator it = distances.begin();
             it != distances.end() && v < valence; ++it)
        {
            std::pair<std::string, int> endAtom = it->second;
            if (!matrixBonds[i][endAtom.second] && !matrixBonds[endAtom.second][i] &&
                binding[std::make_pair(s1, i)] < valences[s1] &&
                binding[endAtom] < valences[endAtom.first])
            {
                ++binding[std::make_pair(s1, i)];
                ++binding[endAtom];
                std::string bond = mendel[s1] < mendel[endAtom.first] ? s1 + endAtom.first : endAtom.first + s1;
                ++bonds[bond];
                matrixBonds[i][endAtom.second] = matrixBonds[endAtom.second][i] = 1;
                ++v;
            }
        }
    }

    for (std::map<std::string, int>::iterator it = _bonds.begin();
         it != _bonds.end(); ++it)
        ofs << it->first << "\t";
    ofs << std::endl;

    for (std::map<std::string, int>::iterator it = _bonds.begin();
         it != _bonds.end(); ++it)
        ofs << bonds[it->first] << "\t";
    ofs << std::endl;
}

void fillDistancesAndBonds1(const Molecule& mol, std::ofstream& ofs)
{

    std::map<std::string, int> bonds;       // num bonds in molecule
    const int size = mol.mAtoms.size();

    std::map<int, std::pair<std::pair<std::string, int>, std::pair<std::string, int> > > distances;

    int numSemiBonds = 0;
    for (int i = 0; i < size; ++i)
    {
        Atom atom1 = mol.mAtoms[i];
        numSemiBonds += valences[atom1.mName];
        std::pair<std::string, int> first = std::make_pair(atom1.mName, i);
        for (int j = i + 1; j < size; ++j)
        {
            Atom atom2 = mol.mAtoms[j];
            std::pair<std::string, int> second = std::make_pair(atom2.mName, j);

            int magnitude = int(1000 * Magnitude(atom1.mCoord - atom2.mCoord));
            distances[magnitude] = std::make_pair(first, second);
        }
    }

    int v = 0; 
    std::vector<std::vector<int> > binding;
    std::vector<int> tmp(size);
    for (int k = 0; k < size; ++k)
        binding.push_back(tmp);

    int num = 0;
    for (std::map<int, std::pair<std::pair<std::string, int>, std::pair<std::string, int> > >::iterator it = distances.begin();
         num < numSemiBonds / 2; ++it, ++num)
    {
        const std::string name1 = it->second.first.first;
        const int num1 = it->second.first.second;
        const std::string name2 = it->second.second.first;
        const int num2 = it->second.second.second;

        const std::string res = mendel[name1] < mendel[name2] ? name1 + name2 : name2 + name1;
        ++bonds[res];
    }

//    for (std::map<std::string, int>::iterator it = _bonds.begin();
//         it != _bonds.end(); ++it)
//        ofs << it->first << "\t";
//    ofs << std::endl;

    for (std::map<std::string, int>::iterator it = _bonds.begin();
         it != _bonds.end(); ++it)
        ofs << bonds[it->first] << "\t";
}


int main(int argc, char* argv[])
{
    std::string argFile;
    std::string energyList;
    if (argc > 1)
    {
        for (int i = 0; i < argc; ++i)
        {
            const char* param = argv[i];
            if (0 == strncmp(param, "-in=", 4))
                argFile = param + 4;
            if (0 == strncmp(param, "-e=", 3))
                energyList = param + 3;
        }
    }

    std::string resDir = argFile + "/Results/";
    if (!core::isDir(resDir.c_str()))
        core::mkDir(resDir.c_str());

    fillMendelAndValences();
    std::vector<std::string> files;
    if (!argFile.empty() && core::listFiles(argFile, files) &&
        !energyList.empty() && core::isFileExists(energyList.c_str()))
    {
        std::map<float, std::string> energies;
        const int maxSymbols = 200;
        char str[maxSymbols];
        FILE* inFile1 = fopen(energyList.c_str(), "r");
        fgets(str, maxSymbols, inFile1);
        fgets(str, maxSymbols, inFile1);
        fgets(str, maxSymbols, inFile1);

        while(fgets(str, maxSymbols, inFile1))
        {
             std::istringstream iss(str);
             float energy;
             std::string name;
             if ((iss >> name >> energy) && !name.empty())
             {
                 size_t pose = name.find_first_of(".");
                 name = std::string::npos == pose ? name : std::string(name.begin(), name.begin() + pose);
                 energies[energy] = name;
             }
        }

        std::ofstream ofs((resDir + "parsed").c_str());
        ofs << "\tName\t\t\t"; 
        for (std::map<std::string, int>::iterator it = _bonds.begin(); it != _bonds.end(); ++it)
            ofs << it->first << "\t";
        ofs << "\tEnergy\n";

        for (std::map<float, std::string>::iterator it = energies.begin();
             it != energies.end(); ++it)
        {
            const std::string name = it->second;
            const std::string path = argFile + "/" + name + ".xyz";
            FILE* inFile = fopen(path.c_str(), "r");
            if (inFile)
            {
                int numAtoms = 0;
                fscanf(inFile, "%d", &numAtoms);

                Molecule mol;
                mol.mEnergy = it->first;
                mol.mName = name;
                mol.mAtoms.assign(numAtoms, Atom());

                for (int j = 0; j < numAtoms; ++j)
                {
                    Atom* atom = &(mol.mAtoms[j]);
                    char name[4]; // max name of atom have 4 symbols
                    fscanf(inFile, "%s", &name);
                    atom->mName = std::string(name);
                    fscanf(inFile, "%f %f %f", &(atom->mCoord.x), &(atom->mCoord.y), &(atom->mCoord.z));
                }

                ofs << path << "\t";

                fillDistancesAndBonds1(mol, ofs);
                ofs << mol.mEnergy << "\n";
                //ofs << mol.mEnergy << "\n_____________________________________________________________\n";
            }

            fclose(inFile);
        }


//        for (int i = 0, size = files.size(); i < size; ++i)
//        {
//            const std::string name = files[i];
//            if (0 == core::getExt(name).compare("xyz"))
//            {
//                const std::string path = argFile + "/" + name;
//                FILE* inFile = fopen(path.c_str(), "r");
//                if (inFile)
//                {
//                    int numAtoms = 0;
//                    fscanf(inFile, "%d", &numAtoms);

//                    Molecule mol;
//                    mol.mName = core::name(name);
//                    mol.mEnergy = energies[mol.mName];
//                    mol.mAtoms.assign(numAtoms, Atom());

//                    for (int j = 0; j < numAtoms; ++j)
//                    {
//                        Atom* atom = &(mol.mAtoms[j]);
//                        char name[4]; // max name of atom have 4 symbols
//                        fscanf(inFile, "%s", &name);
//                        atom->mName = std::string(name);
//                        fscanf(inFile, "%f %f %f", &(atom->mCoord.x), &(atom->mCoord.y), &(atom->mCoord.z));
//                    }

//                    ofs << path << "\t";

//                    fillDistancesAndBonds1(mol, ofs);
//                    ofs << mol.mEnergy << "\n";
//                    //ofs << mol.mEnergy << "\n_____________________________________________________________\n";
//                }

//                fclose(inFile);
//            }
//        }

        ofs.close();
        core::time t;
        getTime(t);

        //bool res = parseMolgen(argFile);
//        std::string time = getTime();
    }

    return 0;
}
