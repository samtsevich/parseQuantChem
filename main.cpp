// This will convert results of MOLGEN to many .mol2 files

#include <iostream>
#include <sstream>
#include <fstream>
#include <stdio.h>
#include <iomanip>
#include <string.h>
#include <vector>
#include <map>
#include <dirent.h>
#include <time.h>
#include <sys/stat.h>
#include <matrix.h>

#include "Vector3D.h"
//#include <sysUtils.h>

typedef unsigned int uint;

const char* headerLine = "Generated by Molgen 5.0";
const char* endLine = "M  END";

const char* mol2Header1 = "@<TRIPOS>MOLECULE\n*****\n";
const char* mol2Header2 = "SMALL\nGASTEIGER\n";

const char* atomHeader = "@<TRIPOS>ATOM\n";
const char* bondHeader = "@<TRIPOS>BOND\n";

const char* goodEnd = "M  END";

const char* middlePartAtom = "   1  LIG11   ";

const std::string molecule = "mol_";
const std::string ext = ".mol2";

template <class T>
std::string to_string(T value)
{
    std::stringstream ss;
    ss << value;
    std::string str;
    ss >> str;
    return str;
}

namespace core
{
    struct time
    {
        short sec;
        short min;
        short hour;
        short day;
        short month;
        short year;

        time()  {}

        std::string timeString()
        {
            return to_string(hour) + "." +
                   to_string(min) + "." +
                   to_string(sec);
        }

        void operator++()
        {
            if (++sec > 59)
            {
                sec = 0;
                if (++min > 59)
                {
                    min = 0;
                    if (++hour > 23)
                        hour = 0;
                }

            }
        }
    };

    std::string getExt(const std::string& path)
    {
        size_t pose = path.find_last_of(".");
        if (std::string::npos == pose)
            return path;
        return std::string(path.begin() + pose + 1, path.end());
    }

    bool isFileExists(const char* path)
    {
        struct stat buffer;
        return (stat (path, &buffer) == 0); 
    }

    bool isDir(const char* path)
    {
        struct stat sb;
        return stat(path, &sb) == 0 && S_ISDIR(sb.st_mode);
    }

    bool mkDir(const char* path)
    {
        return !isDir(path) ?
            mkdir(path, S_IRWXU | S_IRWXG | S_IROTH | S_IXOTH) :
            false;
    }

    bool listFiles(const std::string& path, std::vector<std::string>& files)
    {
        files.clear();
        DIR *dir;
        struct dirent *ent;
        if ((dir = opendir (path.c_str())) != NULL)
        {
            /* print all the files and directories within directory */
            while ((ent = readdir (dir)) != NULL)
            {
                if (strncmp(ent->d_name, ".", 1) == 0 ||
                    strncmp(ent->d_name, "..", 2) == 0)
                    continue;
                files.push_back(std::string(ent->d_name));
            }
            closedir (dir);
            return true;
        }
        else
        {
          /* could not open directory */
          perror ("");
          return false;
        }
    }

    std::string nameWithExt(const std::string& path)
    {
        size_t pose = path.find_last_of("\\/");
        if (std::string::npos == pose)
            return path;
        return std::string(path.begin() + pose + 1, path.end());
    }

    std::string name(const std::string& path)
    {
        size_t pose1 = path.find_last_of("\\/");
        size_t pose2 = path.find_last_of(".");
        if (std::string::npos == pose1)
            return (std::string::npos == pose2) ? path : std::string(path.begin(), path.begin() + pose2);

        return std::string(path.begin() + pose1 + 1, path.begin() + pose2);
    }
};

void getTime(core::time& t)
{
    time_t rawtime;
    struct tm  *timeinfo;

    time (&rawtime);
    timeinfo = localtime(&rawtime);

    t.sec = timeinfo->tm_sec;
    t.min = timeinfo->tm_min;
    t.hour = timeinfo->tm_hour;

    t.day = timeinfo->tm_mday;
    t.month = timeinfo->tm_mon + 1;
    t.year = 1900 + timeinfo->tm_year;
}

std::string getTime()
{
    time_t rawtime;
    struct tm  *timeinfo;
    char buffer[80];

    time (&rawtime);
    timeinfo = localtime(&rawtime);

    //strftime(buffer, 80, "%I.%M.%S", timeinfo);
    strftime(buffer, 80, "%d-%m-%Y %I:%M:%S", timeinfo);
    //std::string str = std::string(timeinfo->tm_hour) + "." + std::string(timeinfo->tm_min) + "." + std::string(timeinfo->tm_sec);
    std::string str(buffer);

    std::string newstr(str.begin() + 11, str.end());
    int pos = newstr.find_last_of(":");
    newstr[pos] = '.';
    pos = newstr.find_last_of(":");
    newstr[pos] = '.';
    //std::cout << newstr << std::endl;
    return newstr;

    //return str;
}

bool parseMolgen(const std::string& path)
{
    bool res = false;
    const int maxSymbols = 200;
    char str[maxSymbols];

    FILE* inFile = fopen(path.c_str(), "r");

    while (inFile != NULL && fgets(str, maxSymbols, inFile))
    {
        if (0 == strncmp(headerLine, str, sizeof(headerLine)))
        {
            core::time t;
            getTime(t);
            std::string timeStr = t.timeString();

            while (core::isFileExists((molecule + timeStr + ext).c_str()))
            {
                ++t;
                timeStr = t.timeString();
            }
            std::string path = molecule + timeStr + ext;

            std::ofstream ofs(path.c_str());
            ofs << mol2Header1;

            //fscanf(inFile, "%d %d", numAtom, numBond)
            fgets(str, maxSymbols, inFile);     // here we have empty line
            fgets(str, maxSymbols, inFile);

            std::istringstream iss(str);
            int numAtom = 0, numBond = 0;
            if ((iss >> numAtom >> numBond) && numAtom > 0 && numBond > 0)
            {
                ofs << " " << numAtom << " " << numBond << " 0 0 0\n";
                ofs << mol2Header2 << "\n" << atomHeader;
                for (int i = 0; i < numAtom; ++i)
                {
                    float x, y, z;
                    std::string atom;
                    fgets(str, maxSymbols, inFile);
                    std::istringstream iss1(str);
                    if ((iss1 >> x >> y >> z >> atom) && !atom.empty())
                        ofs << "\t" << i+1 << "\t" << atom << "\t" << x << "\t" << y << "\t" << z << "\t" << atom << middlePartAtom << "0\n";
                }

                ofs << bondHeader;
                for (int i = 0; i < numBond; ++i)
                {
                    int b, e, mult; // begin, end, multiplicity
                    fgets(str, maxSymbols, inFile);
                    std::istringstream iss1(str);
                    if ((iss1 >> b >> e >> mult) && b > 0 && e > 0 && mult > 0)
                        ofs << "\t" << i+1 << "\t" << b << "\t" << e << "\t" << mult << "\n";
                }
            }
            fgets(str, maxSymbols, inFile);
            res = 0 == strncmp(endLine, str, sizeof(endLine));
            ofs.close();
        }

        //printf("This line = %s", str);
    }

    return res;
}


// map: first - name, second - atom mass
std::map<std::string, int> _mendel;
// map: first - name, second - valence
std::map<std::string, int> _valences;
// map: first - bond, second - num;
std::map<std::string, int> _bonds;
// map: first - bond, second - num;
std::map<std::string, float> _radii;

const std::string resFile_HO = "resFile_HO";
const std::string resFile_HCa = "resFile_HCa";
const std::string resFile_HP = "resFile_HP";
const std::string resFile_OO = "resFile_OO";
const std::string resFile_OP = "resFile_OP";
const std::string resFile_OCa = "resFile_OCa";
const std::string resFile_PP = "resFile_PP";
const std::string resFile_PCa = "resFile_PCa";
const std::string resFile_CaCa = "resFile_CaCa";

void fillMendelAndValences()
{
    _mendel["H"] = 1;
    _mendel["O"] = 16;
    _mendel["P"] = 31;
    _mendel["Ca"] = 40;

    _valences["H"] = 1;
    _valences["O"] = 2;
    _valences["P"] = 5;
    _valences["Ca"] = 2;

    _radii["H"] = 0.31f;
    _radii["O"] = 0.66f;
    _radii["P"] = 1.07f;
    _radii["Ca"] = 1.76f;

    int i = 0;
    _bonds["HO"] = ++i;
    _bonds["HCa"] = ++i;
    _bonds["HP"] = ++i;
    _bonds["OO"] = ++i;
    _bonds["OP"] = ++i;
    _bonds["OCa"] = ++i;
    _bonds["PP"] = ++i;
    _bonds["PCa"] = ++i;
    _bonds["CaCa"] = ++i;

    std::ofstream outfile(resFile_HO.c_str());
    outfile << resFile_HO << std::endl;
    outfile.close();

    std::ofstream outfile1(resFile_HCa.c_str());
    outfile1 << resFile_HCa << std::endl;
    outfile1.close();

//    std::ofstream outfile2(resFile_HO.c_str());
//    outfile2 << resFile_HO << std::endl;
//    outfile2.close();

    std::ofstream outfile3(resFile_HP.c_str());
    outfile3 << resFile_HP << std::endl;
    outfile3.close();

    std::ofstream outfile4(resFile_OO.c_str());
    outfile4 << resFile_OO << std::endl;
    outfile4.close();

    std::ofstream  outfile5(resFile_OP.c_str());
    outfile5 << resFile_OP << std::endl;
    outfile5.close();
    
    std::ofstream outfile6(resFile_CaCa.c_str());
    outfile6 << resFile_CaCa << std::endl;
    outfile6.close();

    std::ofstream outfile7(resFile_PP.c_str());
    outfile << resFile_PP << std::endl;
    outfile.close();

    std::ofstream outfile8(resFile_PCa.c_str());
    outfile << resFile_PCa << std::endl;
    outfile.close();

    std::ofstream outfile9(resFile_CaCa.c_str());
    outfile << resFile_CaCa << std::endl;
    outfile.close();
}

struct Atom
{
    std::string mName;
    Vector3D mCoord;
    int mValence;
};

struct Molecule
{
    std::vector<Atom> mAtoms;
    std::string mName;
    std::map<std::string, int> mBonds;
    unsigned int hash;
    float mEnergy;

    uint getHash()
    {
        hash = 0;
        if (!mBonds.empty() && !mAtoms.empty())
        {
            for (std::map<std::string, int>::iterator it = _bonds.begin();
                 it != _bonds.end(); ++it)
            {
                unsigned int bond = mBonds[it->first];
                hash += bond;
                hash *= 10;
            }
        }
        return hash;
    }

    uint getBondsNum()
    {
        uint num = 0;
        if (!mBonds.empty())
        {
            for (std::map<std::string, int>::iterator it = _bonds.begin();
                 it != _bonds.end(); ++it)
                num += mBonds[it->first];
        }
        return num;
    }
};

// Fill distances files and bonds 
void fillDistancesAndBonds(const Molecule& mol, std::ofstream& ofs)
{

    std::map<std::string, int> bonds;       // num bonds in molecule
    const int size = mol.mAtoms.size();
    
    std::vector< std::vector<char> > matrixBonds;
    std::vector<char> tmp(size, 0);
    for (int i = 0; i < size; ++i)
        matrixBonds.push_back(tmp);


    std::map<std::pair<std::string,int>, int> binding;     // respond to current binding in molecule

    for (int i = 0; i < size; ++i)
    {
        Atom atom1 = mol.mAtoms[i];
        std::string s1 = atom1.mName;
        std::map<float, std::pair<std::string, int> > distances; // to another atoms
        for (int j = i + 1; j < size; ++j)
        {
            Atom atom2 = mol.mAtoms[j];
            std::string s2 = atom2.mName;
            
            float magnitude = int(1000 * Magnitude(atom1.mCoord - atom2.mCoord)) / 1000.f;
            distances[magnitude] = std::make_pair(s2, j);
            
        }
        
        int v = 0,
            valence = _valences[s1];
        for (std::map<float, std::pair<std::string, int> >::iterator it = distances.begin();
             it != distances.end() && v < valence; ++it)
        {
            std::pair<std::string, int> endAtom = it->second;
            if (!matrixBonds[i][endAtom.second] && !matrixBonds[endAtom.second][i] &&
                binding[std::make_pair(s1, i)] < _valences[s1] &&
                binding[endAtom] < _valences[endAtom.first])
            {
                ++binding[std::make_pair(s1, i)];
                ++binding[endAtom];
                std::string bond = _mendel[s1] < _mendel[endAtom.first] ? s1 + endAtom.first : endAtom.first + s1;
                ++bonds[bond];
                matrixBonds[i][endAtom.second] = matrixBonds[endAtom.second][i] = 1;
                ++v;
            }
        }
    }

    for (std::map<std::string, int>::iterator it = _bonds.begin();
         it != _bonds.end(); ++it)
        ofs << it->first << "\t";
    ofs << std::endl;

    for (std::map<std::string, int>::iterator it = _bonds.begin();
         it != _bonds.end(); ++it)
        ofs << bonds[it->first] << "\t";
    ofs << std::endl;
}

void fillDistancesAndBonds1(Molecule& mol)
{
    mol.mBonds.clear();
    const int size = mol.mAtoms.size();

    std::map<int, std::vector<std::pair<int, int> > > distances;

    uint numSemiBonds = 0;
    for (int i = 0; i < size; ++i)
    {
        Atom atom1 = mol.mAtoms[i];
        numSemiBonds += atom1.mValence;
        for (int j = i + 1; j < size; ++j)
        {
            Atom atom2 = mol.mAtoms[j];
            int magnitude = int(1000 * Magnitude(atom1.mCoord - atom2.mCoord));
            distances[magnitude].push_back(std::make_pair(i, j));
        }
    }

    int num = 0;
    for (std::map<int, std::vector<std::pair<int, int> > >::iterator it = distances.begin();
         num < numSemiBonds / 2; ++it)
    {
        std::vector<std::pair<int, int> > tmpBonds = it->second;
        const int tmpBondsSize = tmpBonds.size();
        for (int i = 0; i < tmpBondsSize; ++i)
        {
            std::pair<int, int> bond = tmpBonds[i];
            const std::string name1 = mol.mAtoms[bond.first].mName;
            const std::string name2 = mol.mAtoms[bond.second].mName;

            const float equilibriumDist = _radii[name1] + _radii[name2];
            const float curDist = it->first / 1000.f;
            const float ratioDist = fabs(curDist - equilibriumDist) / equilibriumDist;
            if (ratioDist < 0.2f)
            {
                const std::string res = _mendel[name1] < _mendel[name2] ? name1 + name2 : name2 + name1;
                ++mol.mBonds[res];
                ++num;
            }
        }
    }
}


int main(int argc, char* argv[])
{
    std::string argFile;
    std::string energyList;
    if (argc > 1)
    {
        for (int i = 0; i < argc; ++i)
        {
            const char* param = argv[i];
            if (0 == strncmp(param, "-in=", 4))
                argFile = param + 4;
            if (0 == strncmp(param, "-e=", 3))
                energyList = param + 3;
        }
    }

    std::string resDir = argFile + "/Results/";
    if (!core::isDir(resDir.c_str()))
        core::mkDir(resDir.c_str());

    fillMendelAndValences();
    std::vector<std::string> files;
    if (!argFile.empty() && core::listFiles(argFile, files) &&
        !energyList.empty() && core::isFileExists(energyList.c_str()))
    {
        std::map<float, std::string> energies;
        const int maxSymbols = 200;
        char str[maxSymbols];
        FILE* inFile1 = fopen(energyList.c_str(), "r");
        fgets(str, maxSymbols, inFile1);
        fgets(str, maxSymbols, inFile1);
        fgets(str, maxSymbols, inFile1);

        while(fgets(str, maxSymbols, inFile1))
        {
             std::istringstream iss(str);
             float energy;
             std::string name;
             if ((iss >> name >> energy) && !name.empty())
             {
                 size_t pose = name.find_first_of(".");
                 name = std::string::npos == pose ? name : std::string(name.begin(), name.begin() + pose);
                 energies[energy] = name;
             }
        }

        std::ofstream ofs((resDir + "parsed").c_str());
        ofs << "\tName\t\t\t"; 
        for (std::map<std::string, int>::iterator it = _bonds.begin(); it != _bonds.end(); ++it)
            ofs << it->first << "\t";
        ofs << "\tEnergy\n";

        std::map<uint, Molecule> molMap;
        molMap.clear();

        std::vector<Molecule> molecules(energies.size());
        int ii = 0;
        for (std::map<float, std::string>::iterator it = energies.begin();
             it != energies.end(); ++it)
        {
            const std::string name = it->second;
            const std::string path = argFile + "/" + name + ".xyz";
            FILE* inFile = fopen(path.c_str(), "r");
            if (inFile)
            {
                int numAtoms = 0;
                fscanf(inFile, "%d", &numAtoms);

                Molecule* mol = &(molecules[ii++]);
                mol->mEnergy = it->first;
                mol->mName = name;
                mol->mAtoms.assign(numAtoms, Atom());

                for (int j = 0; j < numAtoms; ++j)
                {
                    Atom* atom = &(mol->mAtoms[j]);
                    char name[4]; // max name of atom have 4 symbols
                    fscanf(inFile, "%s", &name);
                    atom->mName = std::string(name);
                    fscanf(inFile, "%f %f %f", &(atom->mCoord.x), &(atom->mCoord.y), &(atom->mCoord.z));
                    atom->mValence = _valences[name];
                }

                ofs << path << "\t";

                // std::map<std::string, int> bonds;      // num bonds in molecule
                fillDistancesAndBonds1(*mol);
                //    for (std::map<std::string, int>::iterator it = _bonds.begin();
                //         it != _bonds.end(); ++it)
                //        ofs << it->first << "\t";
                //    ofs << std::endl;

                const uint hash = mol->getHash();
                if (molMap.find(hash) == molMap.end() &&
                        10 == mol->getBondsNum())
                    molMap[hash] = *mol;

                //Y.put(0, i, mol.mEnergy);
                //X.put(i, 0, 1.f);
                for (std::map<std::string, int>::iterator it = _bonds.begin();
                     it != _bonds.end(); ++it)
                    ofs << mol->mBonds[it->first] << "\t";

                ofs << mol->mEnergy << "\n";
                //ofs << mol.mEnergy << "\n_____________________________________________________________\n";
            }

            fclose(inFile);;
        }
        ofs.close();

        std::ofstream ofsNew((resDir + "new.txt").c_str());
        for (int j = 0, SIZE = molecules.size();
             j < SIZE; ++j)
        {
            Molecule mol1 = molecules[j];
            for (int k = j + 1; k < SIZE; ++k)
            {
                Molecule mol2 = molecules[k];
                int bondsDiff = 0;
                for (std::map<std::string, int>::iterator it = _bonds.begin();
                     it != _bonds.end(); ++it)
                    bondsDiff += fabs(mol1.mBonds[it->first] - mol2.mBonds[it->first]);
                
                ofsNew << bondsDiff << "\t" << fabs(mol1.mEnergy - mol2.mEnergy)
                       << "\t" << mol1.mName << "\t" << mol2.mName << std::endl;
            }
        }
        ofsNew.close();
        
        if (!molMap.empty()) {
            int i = 0;
            uint mapSize = molMap.size();
            Matrix<float> X(mapSize, _bonds.size() + 1);
            Matrix<float> Y(1, mapSize);

            std::ofstream ofsBonds((resDir + "bonds.txt").c_str());
            std::ofstream ofsEnergy((resDir + "energy.txt").c_str());

            for (std::map<uint, Molecule>::iterator itMol = molMap.begin();
                 itMol != molMap.end(); ++itMol, ++i)
            {
                Molecule mol = itMol->second;
                ofsEnergy << mol.mEnergy << std::endl;
                Y.put(0, i, mol.mEnergy);
                X.put(i, 0, 1.f);

                int j = 1;
                ofsBonds << "1\t";
                for (std::map<std::string, int>::iterator it = _bonds.begin();
                     it != _bonds.end(); ++it, ++j)
                {
                    ofsBonds << mol.mBonds[it->first] << "\t";
                    X.put(i, j, (float)mol.mBonds[it->first]);
                }
                ofsBonds << std::endl;
            }


            ofsBonds.close();
            ofsEnergy.close();

//            std::cout << "Enter to run the program: ";
//            std::cin.ignore().get(); //Pause Command for Linux Terminal

            FILE* inRes = fopen("resCoef", "r");
            std::vector<float> coefs(_bonds.size() + 1);

            for (int i = 0, size = _bonds.size() + 1; i < size; ++i)
                fscanf(inRes, "%f", &(coefs[i]));

            if (!coefs.empty())
            {
                float RSS = 0.f;
                for (std::map<uint, Molecule>::iterator itMol = molMap.begin();
                     itMol != molMap.end(); ++itMol)
                {
                    Molecule mol = itMol->second;

                    float bondsEnergy = 0.f;
                    int j = 0;
                    for (std::map<std::string, int>::iterator it = _bonds.begin();
                         it != _bonds.end(); ++it, ++j)
                        bondsEnergy += mol.mBonds[it->first] * coefs[j];

                    RSS += (mol.mEnergy - bondsEnergy) * (mol.mEnergy - bondsEnergy) / molMap.size();
                }
                std::cout << sqrt(RSS) << std::endl;
            }


//            Matrix<float> X_2 = X * X.getTranspose();
//            X_2.transpose();
//            Matrix<float> new_X = X_2 * X;
//            Matrix<float> new_XX = new_X.getTranspose() * Y.getTranspose();

//            new_XX.getColumns();
//            std::cout << X_2.determinant() << std::endl;
        }


        core::time t;
        getTime(t);

        //bool res = parseMolgen(argFile);
//        std::string time = getTime();
    }

    return 0;
}
