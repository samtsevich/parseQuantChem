// This will convert results of MOLGEN to many .mol2 files

#include <iostream>
#include <sstream>
#include <fstream>
#include <stdio.h>
#include <iomanip>
#include <string.h>
#include <vector>
#include <map>
#include <dirent.h>
#include <time.h>
#include <sys/stat.h>

#include "Vector3D.h"
//#include <sysUtils.h>

const char* headerLine = "Generated by Molgen 5.0";
const char* endLine = "M  END";

const char* mol2Header1 = "@<TRIPOS>MOLECULE\n*****\n";
const char* mol2Header2 = "SMALL\nGASTEIGER\n";

const char* atomHeader = "@<TRIPOS>ATOM\n";
const char* bondHeader = "@<TRIPOS>BOND\n";

const char* goodEnd = "M  END";

const char* middlePartAtom = "   1  LIG11   ";

const std::string molecule = "mol_";
const std::string ext = ".mol2";

template <class T>
std::string to_string(T value)
{
    std::stringstream ss;
    ss << value;
    std::string str;
    ss >> str;
    return str; 
}

namespace core
{
    struct time
    {
        short sec;
        short min;
        short hour;
        short day;
        short month;
        short year;

        time()  {}

        std::string timeString()
        {
            return to_string(hour) + "." +
                   to_string(min) + "." +
                   to_string(sec);
        }

        void operator++()
        {
            if (++sec > 59)
            {
                sec = 0;
                if (++min > 59)
                {
                    min = 0;
                    if (++hour > 23)
                        hour = 0;
                }

            }
        }
    };
    
    std::string getExt(const std::string& path)
    {
        size_t pose = path.find_last_of(".");
        if (std::string::npos == pose)
            return path;
        return std::string(path.begin() + pose + 1, path.end());
    }

    bool isFileExists(const char* path)
    {
        struct stat buffer;   
        return (stat (path, &buffer) == 0); 
    }
    
    bool listFiles(const std::string& path, std::vector<std::string>& files)
    {
        files.clear();
        DIR *dir;
        struct dirent *ent;
        if ((dir = opendir (path.c_str())) != NULL)
        {
            /* print all the files and directories within directory */
            while ((ent = readdir (dir)) != NULL)
            {
                if (strncmp(ent->d_name, ".", 1) == 0 ||
                    strncmp(ent->d_name, "..", 2) == 0)
                    continue;
                //printf ("%s\n", ent->d_name);
                files.push_back(std::string(ent->d_name));
            }
            closedir (dir);
            return true;
        }
        else
        {
          /* could not open directory */
          perror ("");
          return false;
        }
    }

    std::string name(const std::string& path)
    {
        size_t pose = path.find_last_of("\\/");
        if (std::string::npos == pose)
            return path;
        return std::string(path.begin() + pose + 1, path.end());
    }
};

void getTime(core::time& t)
{
    time_t rawtime;
    struct tm  *timeinfo;

    time (&rawtime);
    timeinfo = localtime(&rawtime);

    t.sec = timeinfo->tm_sec;
    t.min = timeinfo->tm_min;
    t.hour = timeinfo->tm_hour;

    t.day = timeinfo->tm_mday;
    t.month = timeinfo->tm_mon + 1;
    t.year = 1900 + timeinfo->tm_year;
}

std::string getTime()
{
    time_t rawtime;
    struct tm  *timeinfo;
    char buffer[80];

    time (&rawtime);
    timeinfo = localtime(&rawtime);

    //strftime(buffer, 80, "%I.%M.%S", timeinfo);
    strftime(buffer, 80, "%d-%m-%Y %I:%M:%S", timeinfo);
    //std::string str = std::string(timeinfo->tm_hour) + "." + std::string(timeinfo->tm_min) + "." + std::string(timeinfo->tm_sec);
    std::string str(buffer);

    std::string newstr(str.begin() + 11, str.end());
    int pos = newstr.find_last_of(":");
    newstr[pos] = '.';
    pos = newstr.find_last_of(":");
    newstr[pos] = '.';
    //std::cout << newstr << std::endl;
    return newstr;

    //return str;
}

bool parseMolgen(const std::string& path)
{
    bool res = false;
    const int maxSymbols = 200;
    char str[maxSymbols];

    FILE* inFile = fopen(path.c_str(), "r");

    while (inFile != NULL && fgets(str, maxSymbols, inFile))
    {
        if (0 == strncmp(headerLine, str, sizeof(headerLine)))
        {
            core::time t;
            getTime(t);
            std::string timeStr = t.timeString();

            while (core::isFileExists((molecule + timeStr + ext).c_str()))
            {
                ++t;
                timeStr = t.timeString();
            }
            std::string path = molecule + timeStr + ext;


            std::ofstream ofs(path.c_str());
            ofs << mol2Header1;

            //fscanf(inFile, "%d %d", numAtom, numBond)
            fgets(str, maxSymbols, inFile);     // here we have empty line
            fgets(str, maxSymbols, inFile);

            std::istringstream iss(str);
            int numAtom = 0, numBond = 0;
            if ((iss >> numAtom >> numBond) && numAtom > 0 && numBond > 0)
            {
                ofs << " " << numAtom << " " << numBond << " 0 0 0\n";
                ofs << mol2Header2 << "\n" << atomHeader;
                for (int i = 0; i < numAtom; ++i)
                {
                    float x, y, z;
                    std::string atom;
                    fgets(str, maxSymbols, inFile);
                    std::istringstream iss1(str);
                    if ((iss1 >> x >> y >> z >> atom) && !atom.empty())
                        ofs << "\t" << i+1 << "\t" << atom << "\t" << x << "\t" << y << "\t" << z << "\t" << atom << middlePartAtom << "0\n";
                }

                ofs << bondHeader;
                for (int i = 0; i < numBond; ++i)
                {
                    int b, e, mult; // begin, end, multiplicity
                    fgets(str, maxSymbols, inFile);
                    std::istringstream iss1(str);
                    if ((iss1 >> b >> e >> mult) && b > 0 && e > 0 && mult > 0)
                        ofs << "\t" << i+1 << "\t" << b << "\t" << e << "\t" << mult << "\n";
                }
            }
            fgets(str, maxSymbols, inFile);
            res = 0 == strncmp(endLine, str, sizeof(endLine));
            ofs.close();
        }

        //printf("This line = %s", str);
    }

    return res;
}


// map: first - name, second - atom mass
std::map<std::string, int> mendel;
// map: first - name, second - valence
std::map<std::string, int> valences;

const std::string resFile_HO = "resFile_HO";
const std::string resFile_HCa = "resFile_HCa";
const std::string resFile_HP = "resFile_HP";
const std::string resFile_OO = "resFile_OO";
const std::string resFile_OP = "resFile_OP";
const std::string resFile_OCa = "resFile_CaCa";
const std::string resFile_PP = "resFile_PP";
const std::string resFile_PCa = "resFile_PCa";
const std::string resFile_CaCa = "resFile_CaCa";

void fillMendelAndValences()
{
    mendel["H"] = 1;
    mendel["O"] = 16;
    mendel["P"] = 31;
    mendel["Ca"] = 40;

    valences["H"] = 1;
    valences["O"] = 2;
    valences["P"] = 5;
    valences["Ca"] = 2;
    
    
    std::ofstream outfile(resFile_HO.c_str());
    outfile << resFile_HO << std::endl;
    outfile.close();

    std::ofstream outfile1(resFile_HCa.c_str());
    outfile1 << resFile_HCa << std::endl;
    outfile1.close();

    std::ofstream outfile2(resFile_HO.c_str());
    outfile2 << resFile_HO << std::endl;
    outfile2.close();

    std::ofstream outfile3(resFile_HP.c_str());
    outfile3 << resFile_HP << std::endl;
    outfile3.close();

    std::ofstream outfile4(resFile_OO.c_str());
    outfile4 << resFile_OO << std::endl;
    outfile4.close();

    std::ofstream  outfile5(resFile_OP.c_str());
    outfile5 << resFile_OP << std::endl;
    outfile5.close();
    
    std::ofstream outfile6(resFile_CaCa.c_str());
    outfile6 << resFile_CaCa << std::endl;
    outfile6.close();

    std::ofstream outfile7(resFile_PP.c_str());
    outfile << resFile_PP << std::endl;
    outfile.close();

    std::ofstream outfile8(resFile_PCa.c_str());
    outfile << resFile_PCa << std::endl;
    outfile.close();

    std::ofstream outfile9(resFile_CaCa.c_str());
    outfile << resFile_CaCa << std::endl;
    outfile.close();
}

struct Atom
{
    std::string mName;
    Vector3D mCoord;
};


// Fill distances files and bonds 
void fillDistancesAndBonds(const std::vector<Atom>& atoms, std::ofstream& ofs)
{
    
    std::map<std::string, int> bonds;       // num bonds in molecule
    const int size = atoms.size();
    
    std::vector< std::vector<char> > matrixBonds;
    std::vector<char> tmp(size, 0);
    for (int i =0; i < size; ++i)
        matrixBonds.push_back(tmp);
    
    
    std::map<std::pair<std::string,int>, int> binding;     // respond to current binding in molecule

    for (int i = 0; i < size; ++i)
    {
        std::string s1 = atoms[i].mName;
        std::map<float, std::pair<std::string, int> > distances; // to another atoms
        for (int j = i + 1; j < size; ++j)
        {
            std::string s2 = atoms[j].mName;
            
            float magnitude = int(1000 * Magnitude(atoms[i].mCoord - atoms[j].mCoord)) / 1000.f;
            distances[magnitude] = std::make_pair(s2, j);
            
            switch (mendel[s1] * mendel[s2])
            {
                // HO = 1 * 16
                case 16:
                {
                    std::ofstream outfile(resFile_HO.c_str(), std::ios_base::app);
                    outfile << magnitude << std::endl;
                    outfile.close();
                }
                // HCa = 1 * 40
                case 40:
                {
                    std::ofstream outfile(resFile_HCa.c_str(), std::ios_base::app);
                    outfile << magnitude << std::endl;
                    outfile.close();
                }
                // HP
                case 31:
                {
                    std::ofstream outfile(resFile_HP.c_str(), std::ios_base::app);
                    outfile << magnitude << std::endl;
                    outfile.close();
                }
                // OO
                case 256:
                {
                    std::ofstream outfile(resFile_OO.c_str(), std::ios_base::app);
                    outfile << magnitude << std::endl;
                    outfile.close();
                }
                // OP
                case 496:
                {
                    std::ofstream outfile(resFile_OP.c_str(), std::ios_base::app);
                    outfile << magnitude << std::endl;
                    outfile.close();
                }
                // OCa
                case 640:
                {
                    std::ofstream outfile(resFile_OCa.c_str(), std::ios_base::app);
                    outfile << magnitude << std::endl;
                    outfile.close();
                }
                // PP
                case 961:
                {
                    std::ofstream outfile(resFile_PP.c_str(), std::ios_base::app);
                    outfile << magnitude << std::endl;
                    outfile.close();
                }
                // PCa
                case 1240:
                {
                    std::ofstream outfile(resFile_PCa.c_str(), std::ios_base::app);
                    outfile << magnitude << std::endl;
                    outfile.close();
                }
                // CaCa
                case 1600:
                {
                    std::ofstream outfile(resFile_CaCa.c_str(), std::ios_base::app);
                    outfile << magnitude << std::endl;
                    outfile.close();
                }
            }
        }
        
        int v = 0,
            valence = valences[atoms[i].mName];
        for (std::map<float, std::pair<std::string, int> >::iterator it = distances.begin();
             it != distances.end() && v < valence; ++it, ++v)
        {
            std::pair<std::string, int> endAtom = it->second;
            if (!matrixBonds[i][endAtom.second] && !matrixBonds[endAtom.second][i] &&
                binding[std::make_pair(s1, i)] < valences[s1] &&
                binding[endAtom] < valences[endAtom.first])
            {
                ++binding[std::make_pair(s1, i)];
                ++binding[endAtom];
                std::string bond = mendel[s1] < mendel[endAtom.first] ? s1 + endAtom.first : endAtom.first + s1;
                ++bonds[bond];
                matrixBonds[i][endAtom.second] = matrixBonds[endAtom.second][i] = 1;
            }
        }
    }

    for (std::map<std::string, int>::iterator it = bonds.begin();
         it != bonds.end(); ++it)
        ofs << it->first << "\t" << it->second << std::endl;
}


int main(int argc, char* argv[])
{
    std::string argFile;
    if (argc > 1)
    {
        const char* param = argv[1];
        if (0 == strncmp(param, "-in=", 4))
            argFile = param + 4;
    }
    
    std::string resDir = argFile + "/Results/";
    fillMendelAndValences();
    std::vector<std::string> files;
    if (!argFile.empty() && core::listFiles(argFile, files))
    {
        for (int i = 0, size = files.size(); i < size; ++i)
        {
            if (0 == core::getExt(files[i]).compare("xyz"))
            {
                const std::string path = argFile + "/" + files[i];
                FILE* inFile = fopen(path.c_str(), "r");
                if (inFile)
                {
                    int numAtoms = 0;
                    fscanf(inFile, "%d", &numAtoms);

                    std::vector<Atom> atoms;

                    for (int j = 0; j < numAtoms; ++j)
                    {
                        Atom atom;
                        char name[4]; // max name of atom have 4 symbols
                        fscanf(inFile, "%s", &name);
                        atom.mName = std::string(name);
                        fscanf(inFile, "%f %f %f", &atom.mCoord.x, &atom.mCoord.y, &atom.mCoord.z);

                        atoms.push_back(atom);
                    }

                    std::ofstream ofs((resDir + files[i] + ".parsed").c_str());
                    ofs << path << std::endl;

                    fillDistancesAndBonds(atoms, ofs);

                    ofs << "------------------------------------------\n";
                    ofs.close();
                }

                fclose(inFile);
            }
        }
        
        core::time t;
        getTime(t);

//        bool res = parseMolgen(argFile);
//        std::string time = getTime();
    }

    return 0;
}
