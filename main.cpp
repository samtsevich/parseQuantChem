// This will convert results of MOLGEN to many .mol2 files

#include <iostream>
#include <sstream>
#include <fstream>
#include <stdio.h>
#include <iomanip>
#include <string.h>
#include <algorithm>
#include <map>
#include <matrix.h>

#include "Vector3D.h"
#include "Molecule.h"

using namespace phys;

const char* headerLine = "Generated by Molgen 5.0";
const char* endLine = "M  END";

const char* mol2Header1 = "@<TRIPOS>MOLECULE\n*****\n";
const char* mol2Header2 = "SMALL\nGASTEIGER\n";

const char* atomHeader = "@<TRIPOS>ATOM\n";
const char* bondHeader = "@<TRIPOS>BOND\n";

const char* goodEnd = "M  END";

const char* middlePartAtom = "   1  LIG11   ";

const std::string molecule = "mol_";
const std::string ext = ".mol2";

bool parseMolgen(const std::string& path)
{
    bool res = false;
    const int maxSymbols = 200;
    char str[maxSymbols];

    FILE* inFile = fopen(path.c_str(), "r");

    while (inFile != NULL && fgets(str, maxSymbols, inFile))
    {
        if (0 == strncmp(headerLine, str, sizeof(headerLine)))
        {
            core::Time t;
            core::getTime(t);
            std::string timeStr = t.timeString();

            while (core::isFileExists((molecule + timeStr + ext).c_str()))
            {
                ++t;
                timeStr = t.timeString();
            }
            std::string path = molecule + timeStr + ext;

            std::ofstream ofs(path.c_str());
            ofs << mol2Header1;

            //fscanf(inFile, "%d %d", numAtom, numBond)
            fgets(str, maxSymbols, inFile);     // here we have empty line
            fgets(str, maxSymbols, inFile);

            std::istringstream iss(str);
            int numAtom = 0, numBond = 0;
            if ((iss >> numAtom >> numBond) && numAtom > 0 && numBond > 0)
            {
                ofs << " " << numAtom << " " << numBond << " 0 0 0\n";
                ofs << mol2Header2 << "\n" << atomHeader;
                for (int i = 0; i < numAtom; ++i)
                {
                    float x, y, z;
                    std::string atom;
                    fgets(str, maxSymbols, inFile);
                    std::istringstream iss1(str);
                    if ((iss1 >> x >> y >> z >> atom) && !atom.empty())
                        ofs << "\t" << i+1 << "\t" << atom << "\t" << x << "\t" << y << "\t" << z << "\t" << atom << middlePartAtom << "0\n";
                }

                ofs << bondHeader;
                for (int i = 0; i < numBond; ++i)
                {
                    int b, e, mult; // begin, end, multiplicity
                    fgets(str, maxSymbols, inFile);
                    std::istringstream iss1(str);
                    if ((iss1 >> b >> e >> mult) && b > 0 && e > 0 && mult > 0)
                        ofs << "\t" << i+1 << "\t" << b << "\t" << e << "\t" << mult << "\n";
                }
            }
            fgets(str, maxSymbols, inFile);
            res = 0 == strncmp(endLine, str, sizeof(endLine));
            ofs.close();
        }

        //printf("This line = %s", str);
    }

    return res;
}


const std::string divider = "=====";


// Fill distances files and bonds 
void fillDistancesAndBonds(const Molecule& mol, std::ofstream& ofs)
{

    std::map<std::string, int> bonds;       // num bonds in molecule
    const int size = mol.mAtoms.size();
    
    std::vector< std::vector<char> > matrixBonds;
    std::vector<char> tmp(size, 0);
    for (int i = 0; i < size; ++i)
        matrixBonds.push_back(tmp);


    std::map<std::pair<std::string,int>, int> binding;     // respond to current binding in molecule

    for (int i = 0; i < size; ++i)
    {
        Atom atom1 = mol.mAtoms[i];
        std::string s1 = atom1.mName;
        std::map<float, std::pair<std::string, int> > distances; // to another atoms
        for (int j = i + 1; j < size; ++j)
        {
            Atom atom2 = mol.mAtoms[j];
            std::string s2 = atom2.mName;
            
            float magnitude = int(1000 * Magnitude(atom1.mCoord - atom2.mCoord)) / 1000.f;
            distances[magnitude] = std::make_pair(s2, j);
            
        }
        
        int v = 0,
            valence = _valences[s1];
        for (std::map<float, std::pair<std::string, int> >::iterator it = distances.begin();
             it != distances.end() && v < valence; ++it)
        {
            std::pair<std::string, int> endAtom = it->second;
            if (!matrixBonds[i][endAtom.second] && !matrixBonds[endAtom.second][i] &&
                binding[std::make_pair(s1, i)] < _valences[s1] &&
                binding[endAtom] < _valences[endAtom.first])
            {
                ++binding[std::make_pair(s1, i)];
                ++binding[endAtom];
                std::string bond = _mendel[s1] < _mendel[endAtom.first] ? s1 + endAtom.first : endAtom.first + s1;
                ++bonds[bond];
                matrixBonds[i][endAtom.second] = matrixBonds[endAtom.second][i] = 1;
                ++v;
            }
        }
    }

    for (std::map<std::string, int>::iterator it = _bonds.begin();
         it != _bonds.end(); ++it)
        ofs << it->first << "\t";
    ofs << std::endl;

    for (std::map<std::string, int>::iterator it = _bonds.begin();
         it != _bonds.end(); ++it)
        ofs << bonds[it->first] << "\t";
    ofs << std::endl;
}

void readEnergies(const std::string& energyList, std::map<float, std::string>& energies,
                  std::map<std::string, float>& invertedEnergies)
{
    energies.clear();
    invertedEnergies.clear();
    const int maxSymbols = 200;
    char str[maxSymbols];
    FILE* inFile1 = fopen(energyList.c_str(), "r");

    while(fgets(str, maxSymbols, inFile1))
    {
         std::istringstream iss(str);
         float energy = 0.f;
         float firstFreq = 0.f;
         std::string name;
         if ((iss >> name >> energy >> firstFreq) && !name.empty() && firstFreq > 0.f)
         {
             size_t pose = name.find_first_of(".");
             name = std::string::npos == pose ? name : std::string(name.begin(), name.begin() + pose);
             energies[energy] = name;
             invertedEnergies[name] = energy;
         }
    }
}

bool readSets(const std::string& path, std::vector<std::vector<std::string> >& sets)
{
    bool res = false;
    sets.clear();
    if (core::isFileExists(path.c_str()))
    {
        std::ifstream ifs(path.c_str());
        std::string name;
        std::vector<std::string> names;
        while (!ifs.eof())
        {
            ifs >> name;
            if (0 == divider.compare(name))
            {
                if (!names.empty())
                    sets.push_back(names);
                names.clear();
            }
            else
                names.push_back(std::string(name));
        }
        res = true;
    }
    return res;
}

bool writeMolMap(const int& num, std::map<uint, Molecule>& molMap, const std::string& resDir)
{
    if (!molMap.empty()) {
        int i = 0;

        std::ofstream ofsBonds((resDir + "bonds.txt").c_str(), std::ios_base::app);
        std::ofstream ofsEnergy((resDir + "energy.txt").c_str(), std::ios_base::app);

        for (std::map<uint, Molecule>::iterator itMol = molMap.begin();
             itMol != molMap.end(); ++itMol, ++i)
        {
            Molecule mol = itMol->second;
            ofsEnergy << mol.mEnergy << std::endl;

            int j = 1;
            switch (num)
            {
            case 0:
                ofsBonds << "1\t0\t0\t";
                break;
            case 1:
                ofsBonds << "0\t1\t0\t";
                break;
            case 2:
                ofsBonds << "0\t0\t1\t";
                break;
            }

            for (std::map<std::string, int>::iterator it = _bonds.begin();
                 it != _bonds.end(); ++it, ++j)
                ofsBonds << mol.mBonds[it->first] << "\t";
            ofsBonds << std::endl;
        }

        ofsBonds.close();
        ofsEnergy.close();
    }
}

int main(int argc, char* argv[])
{
    std::string argFile;
    if (argc > 1)
    {
        for (int i = 0; i < argc; ++i)
        {
            const char* param = argv[i];
            if (0 == strncmp(param, "-in=", 4))
                argFile = param + 4;
        }
    }

    std::string resDir = argFile + "/Results/";
    if (!core::isDir(resDir.c_str()))
        core::mkDir(resDir.c_str());

    std::ofstream ofsBonds((resDir + "bonds.txt").c_str());
    std::ofstream ofsEnergy((resDir + "energy.txt").c_str());
    ofsBonds.close();
    ofsEnergy.close();

    fillMendelAndValences();
    std::vector<std::string> files;
    if (!argFile.empty() && core::listFiles(argFile, files) && !files.empty())
    {
        int num = 0;
        for (int i = 0; i < files.size(); ++i)
        {
            const std::string dir = argFile + "/" + files[i];
            const std::string energyList = dir + "/energies";
            if (core::isDir(dir.c_str()) && core::isFileExists(energyList.c_str()))
            {
                std::map<float, std::string> energies;
                std::map<std::string, float> invertedEnergies;
                readEnergies(energyList, energies, invertedEnergies);

//                for (std::map<std::string, float>::iterator it = invertedEnergies.begin();
//                     it != invertedEnergies.end(); ++it)
//                    energies[it->second] = it->first;

                std::ofstream ofs((resDir + "parsed").c_str());
                ofs << "\tName\t\t\t";
                for (std::map<std::string, int>::iterator it = _bonds.begin(); it != _bonds.end(); ++it)
                    ofs << it->first << "\t";
                ofs << "\tEnergy\n";

                std::map<uint, Molecule> molMap;

                // ==========================================================================
                //        const std::string pathToSets("Ca2PO4_PO_bonds");
                //        std::vector<std::vector<std::string> > names;
                //        bool res1 = readSets(pathToSets, names);

                //        if (res1)
                //        {
                //            molMap.clear();
                //            for (int i = 4, size = names.size(); i < size; ++i)
                //            {
                //                std::vector<Molecule> molecules(names[i].size());
                //                for (int j = 0, sizeNames = molecules.size(); j < sizeNames; ++j)
                //                {
                //                    Molecule* mol = &(molecules[j]);
                //                    mol->mPath = names[i][j];
                //                    mol->mName = core::name(mol->mPath);
                //                    mol->mEnergy = invertedEnergies[mol->mName];
                //                    if (readFromFile(*mol))
                //                        fillDistancesAndBonds1(*mol);

                //                    //std::map<uint, Molecule> molMap;
                //                    const uint hash = mol->getHash();
                //                    if (molMap.find(hash) == molMap.end() &&
                //                        10 == mol->getBondsNum())
                //                    molMap[hash] = *mol;
                //                }

                //                writeMolMap(molMap, resDir);


                //                FILE* inRes = fopen("resCoef", "r");
                //                std::vector<float> coefs(_bonds.size() + 1);

                //                for (int i = 0, size = _bonds.size() + 1; i < size; ++i)
                //                    fscanf(inRes, "%f", &(coefs[i]));

                //                if (!coefs.empty())
                //                {
                //                    float RSS = 0.f;
                //                    for (std::map<uint, Molecule>::iterator itMol = molMap.begin();
                //                         itMol != molMap.end(); ++itMol)
                //                    {
                //                        Molecule mol = itMol->second;

                //                        float bondsEnergy = coefs[0];
                //                        int j = 1;
                //                        for (std::map<std::string, int>::iterator it = _bonds.begin();
                //                             it != _bonds.end(); ++it, ++j)
                //                            bondsEnergy += mol.mBonds[it->first] * coefs[j];

                //                        RSS += (mol.mEnergy - bondsEnergy) * (mol.mEnergy - bondsEnergy) / molMap.size();
                //                    }
                //                    std::cout << sqrt(RSS) << std::endl;
                //                }

                //            }

                //        }


                // ==========================================================================

                std::vector<Molecule> molecules(energies.size());
                int ii = 0;
                for (std::map<float, std::string>::iterator it = energies.begin();
                     it != energies.end(); ++it)
                {
                    const std::string name = it->second;
                    Molecule* mol = &(molecules[ii]);
                    mol->mEnergy = it->first;
                    mol->mName = name;
                    mol->mPath = dir + "/" + name + ".xyz";

                    if (mol->readFromFile())
                    {
                        mol->findDoubleOBond();
                        mol->fillDistancesAndBonds1();

                        ofs << mol->mPath << "\t";
                        ++ii;
                        const uint hash = mol->getHash();
                        if (molMap.find(hash) == molMap.end() &&
                                mol->mustBeBonds() == mol->getBondsNum())
                            molMap[hash] = *mol;

                        for (std::map<std::string, int>::iterator it = _bonds.begin();
                             it != _bonds.end(); ++it)
                            ofs << mol->mBonds[it->first] << "\t";

                        ofs << mol->mEnergy << "\n";
                        //ofs << mol.mEnergy << "\n_____________________________________________________________\n";
                    }
                }
                ofs.close();

//                std::ofstream ofsNew((resDir + "new.txt").c_str());
//                for (int j = 0, SIZE = molecules.size();
//                     j < SIZE; ++j)
//                {
//                    Molecule mol1 = molecules[j];
//                    for (int k = j + 1; k < SIZE; ++k)
//                    {
//                        Molecule mol2 = molecules[k];
//                        int bondsDiff = 0;
//                        for (std::map<std::string, int>::iterator it = _bonds.begin();
//                             it != _bonds.end(); ++it)
//                            bondsDiff += fabs(mol1.mBonds[it->first] - mol2.mBonds[it->first]);

//                        ofsNew << bondsDiff << "\t" << fabs(mol1.mEnergy - mol2.mEnergy)
//                               << "\t" << mol1.mName << "\t" << mol2.mName << std::endl;
//                    }
//                }
//                ofsNew.close();

                //writeMolMap(num, molMap, resDir);

                const int numSets = 3;
                FILE* inRes = fopen("resCoef", "r");
                std::vector<float> coefs(_bonds.size() + numSets);

                for (int i = 0, size = _bonds.size() + numSets; i < size; ++i)
                    fscanf(inRes, "%f", &(coefs[i]));
                
                if (!coefs.empty())
                {
                    float RSS = 0.f;
                    for (std::map<uint, Molecule>::iterator itMol = molMap.begin();
                         itMol != molMap.end(); ++itMol)
                    {
                        Molecule mol = itMol->second;

                        float bondsEnergy = coefs[num];
                        int j = numSets;
                        for (std::map<std::string, int>::iterator it = _bonds.begin();
                             it != _bonds.end(); ++it, ++j)
                        {
                            const float numBonds = mol.mBonds[it->first];
                            bondsEnergy += numBonds * coefs[j];
                        }

                        const float diff = mol.mEnergy - bondsEnergy;
                        RSS += diff * diff / molMap.size();
                    }
                    std::cout << sqrt(RSS) << std::endl;
                }
                ++num;
            }
        }

    }

    return 0;
}
